From b46a75cf4c6a3525dffa341b0192564599c1855a Mon Sep 17 00:00:00 2001
From: LordYuuma <lordyuuma@gmail.com>
Date: Thu, 9 Apr 2020 18:52:34 +0200
Subject: [PATCH] edopro: respect XDG environment variables.

* premake5.lua: (xdg-environment): New option.
* gframe/premake5.lua [xdg-environment]: Define XDG_ENVIRONMENT.
* gframe/data_handler.cpp (DataHandler):
Initialize gGameConfig early.
Load strings from config_directory, falling back to sysconfig_directory.
* gframe/deck_manager.cpp (LoadLFList): Load LFLists from data_directory.
(LoadDeck, LoadDeckDouble, DeleteDeck, RenameDeck): Use data_directory.
* gframe/game.cpp (Initialize): Load skins, replays and singles from
data_directory.
(RefreshDeck): Load decks from data_directory.
(SaveConfig): Save config in config_directory.
(LoadScript): Allow absolute paths.
(PopulateResourceDirectories): Use data_directory and cache_directory
for pics.
(PopulateResourceDirectories)[!YGOPRO_ENVIRONMENT_PATHS]: Use data_directory
for scripts.
(PopulateLocales): Use config_directory.
* gframe/game_config.cpp (GameConfig)[XDG_ENVIRONMENT]: Initialize
cache_directory, config_directory, and data_directory according to
environment.  Set sane values for sysconfig_directory and
sysdata_directory.
(GameConfig): Load conf_file from config_directory, defaulting to
sysconfig_directory.
* gframe/game_config.h (Load,Save): Add path_string& overloads.
(cache_directory,config_directory,data_directory)
(sysconfig_directory,sysdata_directory): New fields.
* gframe/gframe.cpp (main): Don't set gGameConfig, already done.
* gframe/image_downloader.cpp (DownloadPic): Use cache_directory.
* gframe/replay.cpp (BeginRecord,SaveReplay,OpenReplay): Load replays
from data_directory.
* gframe/utils.cpp (CreateResourceFolders): Create config_directory,
data_directory and cache_directory.
Create pics structure in cache_directory, create deck, puzzles, replay
and screenshots folder in data_directory.
* gframe/utils_gui.cpp (TakeScreenshot): Save in data_directory.
---
 gframe/data_handler.cpp     |  6 ++-
 gframe/deck_manager.cpp     | 20 +++++-----
 gframe/game.cpp             | 79 +++++++++++++++++++++----------------
 gframe/game_config.cpp      | 36 ++++++++++++++++-
 gframe/game_config.h        | 13 ++++++
 gframe/gframe.cpp           |  1 -
 gframe/image_downloader.cpp |  9 +++--
 gframe/image_manager.cpp    |  7 ++--
 gframe/premake5.lua         |  3 ++
 gframe/replay.cpp           |  7 ++--
 gframe/single_mode.cpp      |  2 +-
 gframe/utils.cpp            | 23 ++++++-----
 gframe/utils_gui.cpp        |  6 ++-
 premake5.lua                |  5 +++
 14 files changed, 146 insertions(+), 71 deletions(-)

diff --git a/gframe/data_handler.cpp b/gframe/data_handler.cpp
index 5db804e6..135db0ea 100644
--- a/gframe/data_handler.cpp
+++ b/gframe/data_handler.cpp
@@ -98,6 +98,7 @@ void DataHandler::LoadZipArchives() {
 }
 DataHandler::DataHandler() {
 	configs = std::unique_ptr<GameConfig>(new GameConfig);
+	gGameConfig = configs.get();
 	tmp_device = nullptr;
 #ifndef __ANDROID__
 	irr::SIrrlichtCreationParameters params = irr::SIrrlichtCreationParameters();
@@ -129,8 +130,9 @@ DataHandler::DataHandler() {
 	LoadDatabases();
 	LoadPicUrls();
 	deckManager->LoadLFList();
-	auto strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./config/strings.conf"));
-	strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./expansions/strings.conf")) || strings_loaded;
+	auto strings_loaded = dataManager->LoadStrings(configs->config_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = strings_loaded || dataManager->LoadStrings(configs->sysconfig_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = dataManager->LoadStrings(configs->data_directory / EPRO_TEXT("expansions/strings.conf")) || strings_loaded;
 	if(!strings_loaded) {
 		throw std::runtime_error("Failed to load strings!");
 	}
diff --git a/gframe/deck_manager.cpp b/gframe/deck_manager.cpp
index d99c048f..4252215a 100644
--- a/gframe/deck_manager.cpp
+++ b/gframe/deck_manager.cpp
@@ -6,6 +6,7 @@
 #include <algorithm>
 #include <fstream>
 #include "Base64.h"
+#include "game_config.h"
 
 namespace ygo {
 
@@ -74,9 +75,9 @@ bool DeckManager::LoadLFListFolder(path_string path) {
 }
 void DeckManager::LoadLFList() {
 #ifndef YGOPRO_ENVIRONMENT_PATHS
-	LoadLFListSingle(EPRO_TEXT("./expansions/lflist.conf"));
-	LoadLFListSingle(EPRO_TEXT("./lflist.conf"));
-	LoadLFListFolder(EPRO_TEXT("./lflists/"));
+	LoadLFListSingle(gGameConfig->data_directory / EPRO_TEXT("expansions/lflist.conf"));
+	LoadLFListSingle(gGameConfig->data_directory / EPRO_TEXT("lflist.conf"));
+	LoadLFListFolder(gGameConfig->data_directory / EPRO_TEXT("lflists/"));
 #endif
 	LFList nolimit;
 	nolimit.listName = L"N/A"; // N/A
@@ -347,7 +348,7 @@ bool DeckManager::LoadSide(Deck& deck, int* dbuf, int mainc, int sidec) {
 bool DeckManager::LoadDeck(const path_string& file, Deck* deck) {
 	std::vector<int> mainlist;
 	std::vector<int> sidelist;
-	if(!LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist)) {
+	if(!LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist)) {
 		if(!LoadCardList(file, &mainlist, &sidelist))
 			return false;
 	}
@@ -360,8 +361,8 @@ bool DeckManager::LoadDeck(const path_string& file, Deck* deck) {
 bool DeckManager::LoadDeckDouble(const path_string& file, const path_string& file2, Deck* deck) {
 	std::vector<int> mainlist;
 	std::vector<int> sidelist;
-	LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist);
-	LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file2.c_str()), &mainlist, &sidelist);
+	LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist);
+	LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), file2.c_str()), &mainlist, &sidelist);
 	if(deck)
 		LoadDeck(*deck, mainlist, sidelist);
 	else
@@ -369,7 +370,7 @@ bool DeckManager::LoadDeckDouble(const path_string& file, const path_string& fil
 	return true;
 }
 bool DeckManager::SaveDeck(Deck& deck, const path_string& name) {
-	std::ofstream deckfile(fmt::format(EPRO_TEXT("./deck/{}.ydk"), name.c_str()), std::ofstream::out);
+	std::ofstream deckfile(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), name.c_str()), std::ofstream::out);
 	if(!deckfile.is_open())
 		return false;
 	deckfile << "#created by " << BufferIO::EncodeUTF8s(mainGame->ebNickName->getText()) << "\n#main\n";
@@ -489,9 +490,10 @@ void DeckManager::ImportDeckBase64(Deck& deck, const wchar_t* buffer) {
 	LoadDeck(deck, (int*)deck_data.data(), mainc, sidec);
 }
 bool DeckManager::DeleteDeck(Deck& deck, const path_string& name) {
-	return Utils::FileDelete(fmt::format(EPRO_TEXT("./deck/{}.ydk"), name.c_str()));
+	return Utils::FileDelete(fmt::format(gGameConfig->data_directory / EPRO_TEXT("deck/{}.ydk"), name.c_str()));
 }
 bool DeckManager::RenameDeck(const path_string& oldname, const path_string& newname) {
-	return Utils::FileMove(EPRO_TEXT("./deck/") + oldname + EPRO_TEXT(".ydk"), EPRO_TEXT("./deck/") + newname + EPRO_TEXT(".ydk"));
+	path_string deck = gGameConfig->data_directory / EPRO_TEXT("deck");
+	return Utils::FileMove(deck / oldname + EPRO_TEXT(".ydk"), deck / newname + EPRO_TEXT(".ydk"));
 }
 }
diff --git a/gframe/game.cpp b/gframe/game.cpp
index 941d9e7c..ca33531e 100644
--- a/gframe/game.cpp
+++ b/gframe/game.cpp
@@ -140,7 +140,7 @@ bool Game::Initialize() {
 	if(!(ocgcore = LoadOCGcore(gGameConfig->working_directory + EPRO_TEXT("./"))) && !(ocgcore = LoadOCGcore(gGameConfig->working_directory + EPRO_TEXT("./expansions/"))))
 		coreloaded = false;
 #endif
-	skinSystem = new CGUISkinSystem((gGameConfig->working_directory + EPRO_TEXT("./skin")).c_str(), device);
+	skinSystem = new CGUISkinSystem((gGameConfig->data_directory / EPRO_TEXT("skin")).c_str(), device);
 	if(!skinSystem)
 		ErrorLog("Couldn't create skin system");
 	auto logger = device->getLogger();
@@ -1164,7 +1164,7 @@ bool Game::Initialize() {
 	wReplay->getCloseButton()->setVisible(false);
 	wReplay->setVisible(false);
 	lstReplayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wReplay, LISTBOX_REPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
-	lstReplayList->setWorkingPath(L"./replay", true);
+	lstReplayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("replay")), true);
 	lstReplayList->addFilteredExtensions(coreloaded ? std::vector<std::wstring>{L"yrp", L"yrpx"} : std::vector<std::wstring>{ L"yrpx" });
 	lstReplayList->setItemHeight(Scale(18));
 	btnLoadReplay = env->addButton(Scale(470, 355, 570, 380), wReplay, BUTTON_LOAD_REPLAY, gDataManager->GetSysString(1348).c_str());
@@ -1201,7 +1201,7 @@ bool Game::Initialize() {
 	wSinglePlay->setVisible(false);
 	lstSinglePlayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wSinglePlay, LISTBOX_SINGLEPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
 	lstSinglePlayList->setItemHeight(Scale(18));
-	lstSinglePlayList->setWorkingPath(L"./puzzles", true);
+	lstSinglePlayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles")), true);
 	lstSinglePlayList->addFilteredExtensions({L"lua"});
 	btnLoadSinglePlay = env->addButton(Scale(460, 355, 570, 380), wSinglePlay, BUTTON_LOAD_SINGLEPLAY, gDataManager->GetSysString(1357).c_str());
 	defaultStrings.emplace_back(btnLoadSinglePlay, 1357);
@@ -1915,7 +1915,7 @@ void Game::LoadZipArchives() {
 }
 void Game::RefreshDeck(irr::gui::IGUIComboBox* cbDeck) {
 	cbDeck->clear();
-	for(auto& file : Utils::FindFiles(EPRO_TEXT("./deck/"), { EPRO_TEXT("ydk") })) {
+	for(auto& file : Utils::FindFiles(gGameConfig->data_directory / EPRO_TEXT("deck/"), { EPRO_TEXT("ydk") })) {
 		cbDeck->addItem(Utils::ToUnicodeIfNeeded(file.substr(0, file.size() - 4)).c_str());
 	}
 	for(size_t i = 0; i < cbDeck->getItemCount(); ++i) {
@@ -2032,7 +2032,7 @@ void Game::SaveConfig() {
 	gGameConfig->chkIgnore2 = tabSettings.chkIgnoreSpectators->isChecked();
 	gGameConfig->chkHideHintButton = tabSettings.chkHideChainButtons->isChecked();
 	gGameConfig->chkAnime = chkAnime->isChecked();
-	gGameConfig->Save(EPRO_TEXT("./config/system.conf"));
+	gGameConfig->Save(gGameConfig->config_directory / EPRO_TEXT("system.conf"));
 }
 Game::RepoGui* Game::AddGithubRepositoryStatusWindow(const GitRepo* repo) {
 	std::wstring name = BufferIO::DecodeUTF8s(repo->repo_name);
@@ -3057,22 +3057,25 @@ std::vector<char> Game::LoadScript(const std::string& _name) {
 	std::vector<char> buffer;
 	std::ifstream script;
 	path_string name = Utils::ToPathString(_name);
-	for(auto& path : script_dirs) {
-		if(path == EPRO_TEXT("archives")) {
-			auto reader = Utils::FindFileInArchives(EPRO_TEXT("script/"), name);
-			if(reader == nullptr)
-				continue;
-			buffer.resize(reader->getSize());
-			bool readed = reader->read(buffer.data(), buffer.size()) == buffer.size();
-			reader->drop();
-			if(readed)
-				return buffer;
-		} else {
-			script.open(path + name, std::ifstream::binary);
-			if(script.is_open())
-				break;
+	if (name[0] == EPRO_TEXT('/'))
+		script.open(name, std::ifstream::binary);
+	else
+		for(auto& path : script_dirs) {
+			if(path == EPRO_TEXT("archives")) {
+				auto reader = Utils::FindFileInArchives(EPRO_TEXT("script/"), name);
+				if(reader == nullptr)
+					continue;
+				buffer.resize(reader->getSize());
+				bool readed = reader->read(buffer.data(), buffer.size()) == buffer.size();
+				reader->drop();
+				if(readed)
+					return buffer;
+			} else {
+				script.open(path + name, std::ifstream::binary);
+				if(script.is_open())
+					break;
+			}
 		}
-	}
 	if(!script.is_open()) {
 		script.open(name, std::ifstream::binary);
 		if(!script.is_open())
@@ -3136,31 +3139,37 @@ void Game::PopulateResourcesDirectories() {
 				cover_dirs.push_back(image_dir / EPRO_TEXT("cover/"));
 				field_dirs.push_back(image_dir / EPRO_TEXT("field/"));
 			});
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("pics/"));
+	pic_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("pics/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("pics/cover/"));
+	cover_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("pics/cover/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("pics/field/"));
+	field_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("pics/field/"));
 #else
-	script_dirs.push_back(EPRO_TEXT("./expansions/script/"));
-	auto expansions_subdirs = Utils::FindSubfolders(EPRO_TEXT("./expansions/script/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("expansions/script/"));
+	auto expansions_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("expansions/script/"));
 	script_dirs.insert(script_dirs.end(), expansions_subdirs.begin(), expansions_subdirs.end());
 	script_dirs.push_back(EPRO_TEXT("archives"));
-	script_dirs.push_back(EPRO_TEXT("./script/"));
-	auto script_subdirs = Utils::FindSubfolders(EPRO_TEXT("./script/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("script/"));
+	auto script_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("script/"));
 	script_dirs.insert(script_dirs.end(), script_subdirs.begin(), script_subdirs.end());
-	pic_dirs.push_back(EPRO_TEXT("./expansions/pics/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("expansions/pics/"));
 	pic_dirs.push_back(EPRO_TEXT("archives"));
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./expansions/pics/cover/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("pics/"));
+	pic_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("pics/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("expansions/pics/cover/"));
 	cover_dirs.push_back(EPRO_TEXT("archives"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./expansions/pics/field/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("pics/cover/"));
+	cover_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("pics/cover/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("expansions/pics/field/"));
 	field_dirs.push_back(EPRO_TEXT("archives"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("pics/field/"));
+	field_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("pics/field/"));
 #endif
 }
 
 void Game::PopulateLocales() {
-	locales = Utils::FindSubfolders(EPRO_TEXT("./config/languages/"), 1, false);
+	locales = Utils::FindSubfolders(gGameConfig->config_directory / EPRO_TEXT("languages/"), 1, false);
 }
 
 void Game::ApplyLocale(int index, bool forced) {
@@ -3175,7 +3184,7 @@ void Game::ApplyLocale(int index, bool forced) {
 	if(index > 0) {
 		try {
 			gGameConfig->locale = locales[index - 1];
-			auto locale = fmt::format(EPRO_TEXT("./config/languages/{}"), locales[index - 1]);
+			auto locale = fmt::format(gGameConfig->config_directory / EPRO_TEXT("languages/{}"), locales[index - 1]);
 			for(auto& file : Utils::FindFiles(locale, { EPRO_TEXT("cdb") })) {
 				gDataManager->LoadLocaleDB(fmt::format(EPRO_TEXT("{}/{}"), locale, file));
 			}
diff --git a/gframe/game_config.cpp b/gframe/game_config.cpp
index 4d1e7089..f23f86af 100644
--- a/gframe/game_config.cpp
+++ b/gframe/game_config.cpp
@@ -6,9 +6,41 @@
 namespace ygo {
 
 GameConfig::GameConfig() {
-	Load(EPRO_TEXT("./config/system.conf"));
+#if XDG_ENVIRONMENT
+	{
+		const char* home_env = getenv("HOME");
+		path_string home = Utils::ToPathString(home_env);
+
+		const char* data_home = getenv("XDG_DATA_HOME");
+		const char* cache_home = getenv("XDG_CACHE_HOME");
+		const char* config_home = getenv("XDG_CONFIG_HOME");
+
+		if (cache_home)
+			cache_directory = Utils::ToPathString(cache_home) / EPRO_TEXT("ygopro");
+		else
+			cache_directory = home / EPRO_TEXT(".cache/ygopro");
+		if (data_home)
+			data_directory = Utils::ToPathString(data_home) / EPRO_TEXT("ygopro");
+		else
+			data_directory = home / EPRO_TEXT(".local/share/ygopro");
+
+		if (config_home)
+			config_directory = Utils::ToPathString(config_home) / EPRO_TEXT("ygopro");
+		else
+			config_directory = home / EPRO_TEXT(".config/ygopro");
+
+		sysconfig_directory = EPRO_TEXT("/etc/ygopro");
+		sysdata_directory = EPRO_TEXT("/usr/share/ygopro");
+	}
+#endif
+	if(!Load(config_directory / EPRO_TEXT("system.conf")))
+		Load(sysconfig_directory / EPRO_TEXT("system.conf"));
+
 	if(configs.empty()) {
-		std::ifstream conf_file(EPRO_TEXT("./config/configs.json"), std::ifstream::in);
+		std::ifstream conf_file(config_directory / EPRO_TEXT("configs.json"), std::ifstream::in);
+		if (!conf_file)
+			conf_file.open(sysconfig_directory / EPRO_TEXT("configs.json"));
+
 		try {
 			conf_file >> configs;
 		}
diff --git a/gframe/game_config.h b/gframe/game_config.h
index ceff5791..4bd6f59e 100644
--- a/gframe/game_config.h
+++ b/gframe/game_config.h
@@ -16,7 +16,13 @@ struct GameConfig
 {
 	GameConfig();
 	bool Load(const path_char* filename);
+	inline bool Load(const path_string& path) {
+		return Load(path.c_str());
+	}
 	bool Save(const path_char* filename);
+	inline bool Save(const path_string& path) {
+		return Save(path.c_str());
+	}
 
 	bool use_d3d = true;
 	bool vsync = true;
@@ -96,6 +102,13 @@ struct GameConfig
 	path_string locale = EPRO_TEXT("English");
 	path_string working_directory = EPRO_TEXT("./");
 
+	path_string cache_directory = EPRO_TEXT("./");
+	path_string config_directory = EPRO_TEXT("./config");
+	path_string data_directory = EPRO_TEXT("./");
+
+	path_string sysconfig_directory = EPRO_TEXT("./config");
+	path_string sysdata_directory = EPRO_TEXT("./");
+
 	nlohmann::json configs;
 };
 
diff --git a/gframe/gframe.cpp b/gframe/gframe.cpp
index 22770779..7f7f4ff5 100644
--- a/gframe/gframe.cpp
+++ b/gframe/gframe.cpp
@@ -218,7 +218,6 @@ int main(int argc, char* argv[]) {
 		ygo::gImageDownloader = data->imageDownloader.get();
 		ygo::gDataManager = data->dataManager.get();
 		ygo::gSoundManager = data->sounds.get();
-		ygo::gGameConfig = data->configs.get();
 		ygo::gRepoManager = data->gitManager.get();
 		ygo::gdeckManager = data->deckManager.get();
 	}
diff --git a/gframe/image_downloader.cpp b/gframe/image_downloader.cpp
index dc4dea97..6a5adc55 100644
--- a/gframe/image_downloader.cpp
+++ b/gframe/image_downloader.cpp
@@ -4,6 +4,7 @@
 #include <fmt/format.h>
 #include "logging.h"
 #include "utils.h"
+#include "game_config.h"
 #ifdef __ANDROID__
 #include "Android/porting_android.h"
 #endif
@@ -88,22 +89,22 @@ void ImageDownloader::DownloadPic() {
 		downloading_images[type][file.code].status = DOWNLOADING;
 		downloading.push_back(std::move(file));
 		pic_download.unlock();
-		name = fmt::format(EPRO_TEXT("./pics/temp/{}"), code);
+		name = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/{}"), code);
 		if(type == THUMB)
 			type = ART;
 		switch(type) {
 			case ART:
 			case THUMB: {
-				dest_folder = fmt::format(EPRO_TEXT("./pics/{}"), code);
+				dest_folder = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("./pics/{}"), code);
 				break;
 			}
 			case FIELD: {
-				dest_folder = fmt::format(EPRO_TEXT("./pics/field/{}"), code);
+				dest_folder = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("./pics/field/{}"), code);
 				name.append(EPRO_TEXT("_f"));
 				break;
 			}
 			case COVER: {
-				dest_folder = fmt::format(EPRO_TEXT("./pics/cover/{}"), code);
+				dest_folder = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("./pics/cover/{}"), code);
 				name.append(EPRO_TEXT("_c"));
 				break;
 			}
diff --git a/gframe/image_manager.cpp b/gframe/image_manager.cpp
index 08a1896c..0fbc2f0f 100644
--- a/gframe/image_manager.cpp
+++ b/gframe/image_manager.cpp
@@ -9,18 +9,19 @@
 #include <fstream>
 #include <curl/curl.h>
 
-#define BASE_PATH EPRO_TEXT("./textures/")
+#define BASE_PATH EPRO_TEXT("textures/")
 
 namespace ygo {
 
-#define X(x) (textures_path + EPRO_TEXT(x)).c_str()
+#define X(x) (textures_path / EPRO_TEXT(x)).c_str()
 #define GET(obj,fun1,fun2) obj=fun1; if(!obj) obj=fun2;
 #define GTFF(path,ext,w,h) GetTextureFromFile(X(path ext), mainGame->Scale(w), mainGame->Scale(h))
 #define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h)) def_##obj=obj;
 #define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg"))) def_##obj=obj;
 bool ImageManager::Initial() {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
-	textures_path = BASE_PATH;
+	// TODO: Allow overriding through data_directory
+	textures_path = gGameConfig->sysdata_directory / BASE_PATH;
 	GET_TEXTURE_SIZED(tCover[0],"cover", CARD_IMG_WIDTH, CARD_IMG_HEIGHT)
 	GET_TEXTURE_SIZED(tCover[1],"cover2", CARD_IMG_WIDTH, CARD_IMG_HEIGHT)
 	if(!tCover[1]){
diff --git a/gframe/premake5.lua b/gframe/premake5.lua
index cff532ec..0ba74b09 100644
--- a/gframe/premake5.lua
+++ b/gframe/premake5.lua
@@ -21,6 +21,9 @@ local ygopro_config=function(static_core)
 	if _OPTIONS["environment-paths"] then
 		defines { "YGOPRO_ENVIRONMENT_PATHS" }
 	end
+	if _OPTIONS["xdg-environment"] then
+		defines { "XDG_ENVIRONMENT" }
+	end
 
 	includedirs "../ocgcore"
 	links { "clzma", "freetype", "Irrlicht" }
diff --git a/gframe/replay.cpp b/gframe/replay.cpp
index a3668c15..1d20dea5 100644
--- a/gframe/replay.cpp
+++ b/gframe/replay.cpp
@@ -1,4 +1,5 @@
 #include "replay.h"
+#include "game_config.h"
 #include <algorithm>
 #include <fstream>
 #include "lzma/LzmaLib.h"
@@ -38,7 +39,7 @@ void Replay::BeginRecord(bool write) {
 		fp.close();
 	is_recording = false;
 	if(write) {
-		fp.open("./replay/_LastReplay.yrpX", std::ofstream::binary);
+		fp.open(gGameConfig->data_directory / EPRO_TEXT("replay/_LastReplay.yrpX"), std::ofstream::binary);
 		if(!fp.is_open()) {
 			return;
 		}
@@ -94,7 +95,7 @@ void Replay::EndRecord(size_t size) {
 	is_recording = false;
 }
 void Replay::SaveReplay(const path_string& name) {
-	std::ofstream replay_file(fmt::format(EPRO_TEXT("./replay/{}.yrpX"), name.c_str()), std::ofstream::binary);
+	std::ofstream replay_file(fmt::format(gGameConfig->data_directory / EPRO_TEXT("replay/{}.yrpX"), name.c_str()), std::ofstream::binary);
 	if(!replay_file.is_open())
 		return;
 	replay_file.write((char*)&pheader, sizeof(pheader));
@@ -146,7 +147,7 @@ bool Replay::OpenReplay(const path_string& name) {
 	Reset();
 	std::ifstream replay_file(name, std::ifstream::binary);
 	if(!replay_file.is_open()) {
-		replay_file.open(EPRO_TEXT("./replay/") + name, std::ifstream::binary);
+		replay_file.open(gGameConfig->data_directory / EPRO_TEXT("replay/") + name, std::ifstream::binary);
 		if(!replay_file.is_open()) {
 			replay_name.clear();
 			return false;
diff --git a/gframe/single_mode.cpp b/gframe/single_mode.cpp
index f4a25d4d..f0d7cc85 100644
--- a/gframe/single_mode.cpp
+++ b/gframe/single_mode.cpp
@@ -142,7 +142,7 @@ restart:
 		if(open_file) {
 			script_name = Utils::ToUTF8IfNeeded(open_file_name);
 			if(!mainGame->LoadScript(pduel, script_name)) {
-				script_name = Utils::ToUTF8IfNeeded(EPRO_TEXT("./puzzles/") + open_file_name);
+				script_name = Utils::ToUTF8IfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles") / open_file_name);
 				if(!mainGame->LoadScript(pduel, script_name))
 					loaded = false;
 			}
diff --git a/gframe/utils.cpp b/gframe/utils.cpp
index ca7be468..6585fdd1 100644
--- a/gframe/utils.cpp
+++ b/gframe/utils.cpp
@@ -12,6 +12,7 @@
 #include <unistd.h>
 #endif
 #include "bufferio.h"
+#include "game_config.h"
 
 namespace ygo {
 	std::vector<irr::io::IFileArchive*> Utils::archives;
@@ -112,15 +113,19 @@ namespace ygo {
 	}
 	void Utils::CreateResourceFolders() {
 		//create directories if missing
-		MakeDirectory(EPRO_TEXT("deck"));
-		MakeDirectory(EPRO_TEXT("puzzles"));
-		MakeDirectory(EPRO_TEXT("pics"));
-		MakeDirectory(EPRO_TEXT("pics/field"));
-		MakeDirectory(EPRO_TEXT("pics/cover"));
-		MakeDirectory(EPRO_TEXT("pics/temp/"));
-		ClearDirectory(EPRO_TEXT("pics/temp/"));
-		MakeDirectory(EPRO_TEXT("replay"));
-		MakeDirectory(EPRO_TEXT("screenshots"));
+		MakeDirectory(gGameConfig->config_directory);
+		MakeDirectory(gGameConfig->data_directory);
+		MakeDirectory(gGameConfig->cache_directory);
+
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("deck"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("puzzles"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/field"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/cover"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		ClearDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("replay"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("screenshots"));
 	}
 
 	void Utils::FindFiles(const path_string& path, const std::function<void(path_string, bool, void*)>& cb, void* payload) {
diff --git a/gframe/utils_gui.cpp b/gframe/utils_gui.cpp
index 96af7e3c..b9c28ce9 100644
--- a/gframe/utils_gui.cpp
+++ b/gframe/utils_gui.cpp
@@ -1,4 +1,6 @@
+#include <fmt/format.h>
 #include "utils_gui.h"
+#include "game_config.h"
 #include <IrrlichtDevice.h>
 #include <ICursorControl.h>
 #ifdef _WIN32
@@ -30,8 +32,8 @@ void GUIUtils::TakeScreenshot(irr::IrrlichtDevice* device)
 	const auto driver = device->getVideoDriver();
 	const auto image = driver->createScreenShot();
 	if (image) { // In theory this should never be NULL
-		irr::c8 filename[64];
-		snprintf(filename, 64, "screenshots/ygopro_%u.png", device->getTimer()->getRealTime());
+		path_string file_name = gGameConfig->data_directory / fmt::format(EPRO_TEXT("screenshots/ygopro_{}.png"), device->getTimer()->getRealTime());
+		irr::core::string<path_char> filename(file_name.c_str());
 		if (!driver->writeImageToFile(image, filename))
 			device->getLogger()->log(L"Failed to take screenshot.", irr::ELL_WARNING);
 		image->drop();
diff --git a/premake5.lua b/premake5.lua
index 4309647c..7e259ab4 100644
--- a/premake5.lua
+++ b/premake5.lua
@@ -46,6 +46,11 @@ newoption
 	trigger = "environment-paths",
 	description = "Read databases, scripts and images from YGOPRO_*_PATH"
 }
+newoption
+{
+	trigger = "xdg-environment",
+	description = "Use XDG config, data and cache directories."
+}
 workspace "ygo"
 	location "build"
 	language "C++"
-- 
2.26.0

