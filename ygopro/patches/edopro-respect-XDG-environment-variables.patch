From 835ee37d3aa622f5d5f88899979831a1a85dd30b Mon Sep 17 00:00:00 2001
From: LordYuuma <lordyuuma@gmail.com>
Date: Sat, 12 Jun 2021 01:19:44 +0200
Subject: [PATCH] edopro: Respect XDG paths.

* premake5.lua: (xdg-environment): New option.
* gframe/data_handler.cpp (DataHandler):
Initialize gGameConfig early.
Load strings from config_directory, falling back to sysconfig_directory.
* gframe/deck_manager.cpp (LoadLFList): Load LFLists from data_directory.
(LoadDeck, LoadDeckDouble, DeleteDeck, RenameDeck): Use data_directory.
* gframe/game.cpp (Initialize): Load skins, replays and singles from
data_directory.
(ApplySkin): Load textures from data_directory.
(RefreshDeck): Load decks from data_directory.
(SaveConfig): Save config in config_directory.
(LoadScript): Allow absolute paths.
(PopulateResourceDirectories): Use data_directory and cache_directory
for pics.
(PopulateResourceDirectories)[!YGOPRO_ENVIRONMENT_PATHS]: Use data_directory
for scripts.
(PopulateLocales): Use config_directory.
* gframe/game_config.cpp [XDG_ENVIRONMENT,_WIN32](GetSpecialFolder): New
procedure.
(GameConfig)[XDG_ENVIRONMENT]: Initialize cache_directory,
config_directory, and data_directory according to environment.
Set sane values for sysconfig_directory and sysdata_directory.
(GameConfig)[XDG_ENVIRONMENT, _WIN32]: Default cache directory to
CSIDL_INTERNET_CACHE.
Default config and data directory to CSIDL_LOCAL_APPDATA.
(GameConfig): Load conf_file from config_directory, defaulting to
sysconfig_directory.
* gframe/game_config.h (Load,Save): Add path_string& overloads.
(cache_directory,config_directory,data_directory)
(sysconfig_directory,sysdata_directory): New fields.
* gframe/gframe.cpp (main): Don't set gGameConfig, already done.
* gframe/image_downloader.cpp (DownloadPic): Use cache_directory.
* gframe/image_manager.h: (textures_path2): New field.
(InitTexture_,InitTextureSized_,GetTexture_,GetTextureSized_): New helpers.
* gframe/image_manager.cpp (Initial): Initialize textures_path with
data_directory and textures_path2 with sysdata_directory.
(InitTexture_,InitTextureSized_,GetTexture_,GetTextureSized_): Implement.
(X,GET): Removed macro.
(GET_TEXTURE_SIZED,GET_TEXTURE): Implement in terms of InitTextureSized_,
InitTexture_, GetTextureSized_ and GetTexture_.
(RefreshCovers): Refactor away some duplicate operations now that we have
textures_path2.
* gframe/premake5.lua [xdg-environment]: Define XDG_ENVIRONMENT.
* gframe/replay.cpp (BeginRecord,SaveReplay,OpenReplay): Load replays
from data_directory.
* gframe/sound_manager.cpp (RefreshBGMList,RefreshBGMDir): Properly expand
working_directory.
* gframe/utils.h (PathIsRelative): New procedure.
* gframe/utils.cpp (CreateResourceFolders): Create config_directory,
data_directory and cache_directory.
Create pics structure in cache_directory, create deck, puzzles, replay
and screenshots folder in data_directory.
(PathIsRelative): Implement it.
* gframe/utils_gui.cpp (TakeScreenshot): Save in data_directory.
---
 gframe/data_handler.cpp     |   9 +++++----
 gframe/deck_manager.cpp     |  20 ++++++++++++--------
 gframe/deck_manager.h       |   1 +
 gframe/game.cpp             |  58 ++++++++++++++++++++++++++++++----------------------------
 gframe/game_config.cpp      |  92 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 gframe/game_config.h        |  13 +++++++++++++
 gframe/gframe.cpp           |   1 -
 gframe/image_downloader.cpp |  31 ++++++++++++-------------------
 gframe/image_manager.cpp    | 107 ++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------------------------------------------
 gframe/image_manager.h      |   5 +++++
 gframe/premake5.lua         |   3 +++
 gframe/replay.cpp           |   6 ++++--
 gframe/single_mode.cpp      |   2 +-
 gframe/sound_manager.cpp    |  70 +++++++++++++++++++++++++++++++++++-----------------------------------
 gframe/utils.cpp            |  44 +++++++++++++++++++++++++++++++++++---------
 gframe/utils.h              |   1 +
 gframe/utils_gui.cpp        |   4 ++--
 premake5.lua                |   5 +++++
 18 files changed, 304 insertions(+), 168 deletions(-)

diff --git a/gframe/data_handler.cpp b/gframe/data_handler.cpp
index bdc1cf0..a904dcc 100644
--- a/gframe/data_handler.cpp
+++ b/gframe/data_handler.cpp
@@ -127,23 +127,24 @@ DataHandler::DataHandler(epro::path_stringview working_dir) {
 #endif
 	filesystem = new irr::io::CFileSystem();
 	dataManager = std::unique_ptr<DataManager>(new DataManager());
-	auto strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./config/strings.conf"));
-	strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./expansions/strings.conf")) || strings_loaded;
+	auto strings_loaded = dataManager->LoadStrings(configs->config_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = strings_loaded || dataManager->LoadStrings(configs->sysconfig_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = dataManager->LoadStrings(configs->data_directory / EPRO_TEXT("expansions/strings.conf")) || strings_loaded;
 	if(!strings_loaded)
 		throw std::runtime_error("Failed to load strings!");
 	Utils::filesystem = filesystem;
 	Utils::working_dir = Utils::NormalizePath(working_dir);
 	LoadZipArchives();
 	deckManager = std::unique_ptr<DeckManager>(new DeckManager());
 	gitManager = std::unique_ptr<RepoManager>(new RepoManager());
-	sounds = std::unique_ptr<SoundManager>(new SoundManager(configs->soundVolume / 100.0, configs->musicVolume / 100.0, configs->enablesound, configs->enablemusic, Utils::working_dir));
+	sounds = std::unique_ptr<SoundManager>(new SoundManager(configs->soundVolume / 100.0, configs->musicVolume / 100.0, configs->enablesound, configs->enablemusic, configs->data_directory));
 	gitManager->LoadRepositoriesFromJson(configs->user_configs);
 	gitManager->LoadRepositoriesFromJson(configs->configs);
 	imageDownloader = std::unique_ptr<ImageDownloader>(new ImageDownloader());
 	LoadDatabases();
 	LoadPicUrls();
 	deckManager->LoadLFList();
-	WindBotPanel::absolute_deck_path = Utils::ToUnicodeIfNeeded(Utils::GetAbsolutePath(EPRO_TEXT("./deck")));
+	WindBotPanel::absolute_deck_path = Utils::ToUnicodeIfNeeded(configs->data_directory / EPRO_TEXT("./deck"));
 }
 DataHandler::~DataHandler() {
 	if(filesystem)
diff --git a/gframe/deck_manager.cpp b/gframe/deck_manager.cpp
index 472bb8f..5f42a82 100644
--- a/gframe/deck_manager.cpp
+++ b/gframe/deck_manager.cpp
@@ -7,6 +7,9 @@
 #include "data_manager.h"
 #include "game.h"
 #include <IGUIEditBox.h>
+#include <iostream>
+#include <fstream>
+#include <fmt/format.h>
 #include "Base64.h"
 #include "utils.h"
 #include "client_card.h"
@@ -422,8 +425,8 @@ bool DeckManager::LoadDeck(epro::path_stringview file, Deck* deck, bool separate
 	cardlist_type mainlist;
 	cardlist_type sidelist;
 	cardlist_type extralist;
-	if(!LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file), &mainlist, separated ? &extralist : nullptr, &sidelist)) {
-		if(!LoadCardList({ file.data(), file.size() }, &mainlist, separated ? &extralist : nullptr, &sidelist))
+	if(!LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("deck/{}.ydk"), file), &mainlist, separated ? &extralist : nullptr, &sidelist)) {
+		if(!LoadCardList({file.data(), file.size()}, &mainlist, separated ? &extralist : nullptr, &sidelist))
 			return false;
 	}
 	if(deck)
@@ -435,16 +438,16 @@ bool DeckManager::LoadDeck(epro::path_stringview file, Deck* deck, bool separate
 bool DeckManager::LoadDeckDouble(epro::path_stringview file, epro::path_stringview file2, Deck* deck) {
 	cardlist_type mainlist;
 	cardlist_type sidelist;
-	LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file), &mainlist, nullptr, &sidelist);
-	LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file2), &mainlist, nullptr, &sidelist);
+	LoadCardList(gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), file), &mainlist, nullptr, &sidelist);
+	LoadCardList(gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), file2), &mainlist, nullptr, &sidelist);
 	if(deck)
 		LoadDeck(*deck, mainlist, sidelist);
 	else
 		LoadDeck(current_deck, mainlist, sidelist);
 	return true;
 }
 bool DeckManager::SaveDeck(Deck& deck, epro::path_stringview name) {
-	const auto fullname = fmt::format(EPRO_TEXT("./deck/{}.ydk"), name);
+	const auto fullname = gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name);
 #if defined(__MINGW32__) && defined(UNICODE)
 	auto fd = _wopen(fullname.data(), _O_WRONLY);
 	if(fd == -1)
@@ -468,7 +471,7 @@ bool DeckManager::SaveDeck(Deck& deck, epro::path_stringview name) {
 	return true;
 }
 bool DeckManager::SaveDeck(epro::path_stringview name, const cardlist_type& mainlist, const cardlist_type& extralist, const cardlist_type& sidelist) {
-	const auto fullname = fmt::format(EPRO_TEXT("./deck/{}.ydk"), name);
+	const auto fullname = gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name);
 #if defined(__MINGW32__) && defined(UNICODE)
 	auto fd = _wopen(fullname.data(), _O_WRONLY);
 	if(fd == -1)
@@ -619,9 +622,10 @@ bool DeckManager::ImportDeckBase64Omega(Deck& deck, epro::wstringview buffer) {
 	return true;
 }
 bool DeckManager::DeleteDeck(Deck& deck, epro::path_stringview name) {
-	return Utils::FileDelete(fmt::format(EPRO_TEXT("./deck/{}.ydk"), name));
+	return Utils::FileDelete(gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name));
 }
 bool DeckManager::RenameDeck(epro::path_stringview oldname, epro::path_stringview newname) {
-	return Utils::FileMove(fmt::format(EPRO_TEXT("./deck/{}.ydk"), oldname), fmt::format(EPRO_TEXT("./deck/{}.ydk"), newname));
+	epro::path_string deck = gGameConfig->data_directory / EPRO_TEXT("deck");
+	return Utils::FileMove(deck / oldname + EPRO_TEXT(".ydk"), deck / newname + EPRO_TEXT(".ydk"));
 }
 }
diff --git a/gframe/deck_manager.h b/gframe/deck_manager.h
index b5c9d14..84e0c4f 100644
--- a/gframe/deck_manager.h
+++ b/gframe/deck_manager.h
@@ -7,6 +7,7 @@
 #include "network.h"
 #include "text_types.h"
 #include "data_manager.h"
+#include "game_config.h"
 
 namespace ygo {
 
diff --git a/gframe/game.cpp b/gframe/game.cpp
index cf8b7d3..b86b1d3 100644
--- a/gframe/game.cpp
+++ b/gframe/game.cpp
@@ -125,7 +125,7 @@ bool Game::Initialize() {
 	if(!(ocgcore = LoadOCGcore(Utils::working_dir)) && !(ocgcore = LoadOCGcore(fmt::format(EPRO_TEXT("{}/expansions/"), Utils::working_dir))))
 		coreloaded = false;
 #endif
-	skinSystem = new CGUISkinSystem(fmt::format(EPRO_TEXT("{}/skin"), Utils::working_dir).data(), device);
+	skinSystem = new CGUISkinSystem(fmt::format(EPRO_TEXT("{}/skin"), gGameConfig->data_directory).data(), device);
 	if(!skinSystem)
 		throw std::runtime_error("Couldn't create skin system");
 	linePatternGL = 0x0f0f;
@@ -1024,7 +1024,7 @@ bool Game::Initialize() {
 	stHandTestSettings->setEnabled(coreloaded);
 	stHandTestSettings->setTextAlignment(irr::gui::EGUIA_CENTER, irr::gui::EGUIA_CENTER);
 	defaultStrings.emplace_back(stHandTestSettings, 1375);
-	
+
 	wHandTest = env->addWindow(Scale(mainMenuLeftX, 200, mainMenuRightX, 450), false, gDataManager->GetSysString(1297).data());
 	wHandTest->getCloseButton()->setVisible(false);
 	wHandTest->setVisible(false);
@@ -1175,7 +1175,7 @@ bool Game::Initialize() {
 	wReplay->getCloseButton()->setVisible(false);
 	wReplay->setVisible(false);
 	lstReplayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wReplay, LISTBOX_REPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
-	lstReplayList->setWorkingPath(L"./replay", true);
+	lstReplayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("replay")), true);
 	lstReplayList->addFilteredExtensions({L"yrp", L"yrpx"});
 	lstReplayList->setItemHeight(Scale(18));
 	btnLoadReplay = env->addButton(Scale(470, 355, 570, 380), wReplay, BUTTON_LOAD_REPLAY, gDataManager->GetSysString(1348).data());
@@ -1215,7 +1215,7 @@ bool Game::Initialize() {
 	wSinglePlay->setVisible(false);
 	lstSinglePlayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wSinglePlay, LISTBOX_SINGLEPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
 	lstSinglePlayList->setItemHeight(Scale(18));
-	lstSinglePlayList->setWorkingPath(L"./puzzles", true);
+	lstSinglePlayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles")), true);
 	lstSinglePlayList->addFilteredExtensions({L"lua"});
 	btnLoadSinglePlay = env->addButton(Scale(470, 355, 570, 380), wSinglePlay, BUTTON_LOAD_SINGLEPLAY, gDataManager->GetSysString(1357).data());
 	defaultStrings.emplace_back(btnLoadSinglePlay, 1357);
@@ -1982,7 +1982,7 @@ bool Game::ApplySkin(const epro::path_string& skinname, bool reload, bool firstr
 #include "custom_skin_enum.inl"
 #undef DECLR
 #undef CLR
-			imageManager.ChangeTextures(fmt::format(EPRO_TEXT("./skin/{}/textures/"), prev_skin));
+			imageManager.ChangeTextures(gGameConfig->data_directory / EPRO_TEXT("skin/") + prev_skin + EPRO_TEXT("/textures/"));
 		} else {
 			applied = false;
 			auto skin = env->createSkin(irr::gui::EGST_WINDOWS_METALLIC);
@@ -2026,7 +2026,7 @@ bool Game::ApplySkin(const epro::path_string& skinname, bool reload, bool firstr
 }
 void Game::RefreshDeck(irr::gui::IGUIComboBox* cbDeck) {
 	cbDeck->clear();
-	for(auto& file : Utils::FindFiles(EPRO_TEXT("./deck/"), { EPRO_TEXT("ydk") })) {
+	for(auto& file : Utils::FindFiles(gGameConfig->data_directory / EPRO_TEXT("deck/"), { EPRO_TEXT("ydk") })) {
 		file.erase(file.size() - 4);
 		cbDeck->addItem(Utils::ToUnicodeIfNeeded(file).data());
 	}
@@ -2161,7 +2161,7 @@ void Game::SaveConfig() {
 #ifdef UPDATE_URL
 	gGameConfig->noClientUpdates = gSettings.chkUpdates->isChecked();
 #endif
-	gGameConfig->Save(EPRO_TEXT("./config/system.conf"));
+	gGameConfig->Save(gGameConfig->config_directory / EPRO_TEXT("system.conf"));
 }
 Game::RepoGui* Game::AddGithubRepositoryStatusWindow(const GitRepo* repo) {
 	std::wstring name = BufferIO::DecodeUTF8(repo->repo_name);
@@ -3326,6 +3326,8 @@ std::wstring Game::ReadPuzzleMessage(epro::wstringview script_name) {
 	return BufferIO::DecodeUTF8(res);
 }
 epro::path_string Game::FindScript(epro::path_stringview name, irr::io::IReadFile** retarchive) {
+ 	if (!Utils::PathIsRelative(name))
+		return epro::path_string(name);
 	for(auto& path : script_dirs) {
 		if(path == EPRO_TEXT("archives")) {
 			if(auto tmp = Utils::FindFileInArchives(EPRO_TEXT("script/"), name)) {
@@ -3461,32 +3463,32 @@ void Game::PopulateResourcesDirectories() {
 				cover_dirs.push_back(image_dir / EPRO_TEXT("cover/"));
 				field_dirs.push_back(image_dir / EPRO_TEXT("field/"));
 			});
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
 #else
-	script_dirs.push_back(EPRO_TEXT("./expansions/script/"));
-	auto expansions_subdirs = Utils::FindSubfolders(EPRO_TEXT("./expansions/script/"));
-	script_dirs.insert(script_dirs.end(), std::make_move_iterator(expansions_subdirs.begin()), std::make_move_iterator(expansions_subdirs.end()));
-	script_dirs.push_back(EPRO_TEXT("archives"));
-	script_dirs.push_back(EPRO_TEXT("./script/"));
-	auto script_subdirs = Utils::FindSubfolders(EPRO_TEXT("./script/"));
-	script_dirs.insert(script_dirs.end(), std::make_move_iterator(script_subdirs.begin()), std::make_move_iterator(script_subdirs.end()));
-	pic_dirs.push_back(EPRO_TEXT("./expansions/pics/"));
-	pic_dirs.push_back(EPRO_TEXT("archives"));
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./expansions/pics/cover/"));
-	cover_dirs.push_back(EPRO_TEXT("archives"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./expansions/pics/field/"));
-	field_dirs.push_back(EPRO_TEXT("archives"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	auto expansions_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	script_dirs.insert(script_dirs.end(), expansions_subdirs.begin(), expansions_subdirs.end());
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	auto script_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	script_dirs.insert(script_dirs.end(), script_subdirs.begin(), script_subdirs.end());
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/cover/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/field/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
 #endif
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/field/"));
+	pic_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/field/"));
 }
 
 void Game::PopulateLocales() {
 	locales.clear();
-	for(auto& locale : Utils::FindSubfolders(EPRO_TEXT("./config/languages/"), 1, false)) {
+	for(auto& locale : Utils::FindSubfolders(gGameConfig->config_directory / EPRO_TEXT("languages/"), 1, false)) {
 		locales.emplace_back(locale, std::vector<epro::path_string>());
 	}
 }
@@ -3503,7 +3505,7 @@ void Game::ApplyLocale(size_t index, bool forced) {
 	if(index > 0) {
 		try {
 			gGameConfig->locale = locales[index - 1].first;
-			auto locale = fmt::format(EPRO_TEXT("./config/languages/{}"), gGameConfig->locale);
+			auto locale = fmt::format(gGameConfig->config_directory / EPRO_TEXT("languages/{}"), gGameConfig->locale);
 			for(auto& file : Utils::FindFiles(locale, { EPRO_TEXT("cdb") })) {
 				gDataManager->LoadLocaleDB(fmt::format(EPRO_TEXT("{}/{}"), locale, file));
 			}
diff --git a/gframe/game_config.cpp b/gframe/game_config.cpp
index 834a450..36a5cea 100644
--- a/gframe/game_config.cpp
+++ b/gframe/game_config.cpp
@@ -9,21 +9,104 @@
 #include <fcntl.h>
 #include <ext/stdio_filebuf.h>
 #endif
+#if XDG_ENVIRONMENT && _WIN32
+#include <Shlobj.h>
+#include <Shlobj_core.h>
+
+namespace
+{
+	epro::path_string
+	GetSpecialFolder (int csidl)
+	{
+		std::vector<wchar_t> path;
+		HRESULT hr;
+		LPITEMIDLIST pidl = NULL;
+		BOOL b;
+		epro::path_string result;
+		path.reserve(MAX_PATH+1);
+
+		hr = SHGetFolderPathA (NULL, csidl, NULL, 0, path.data());
+		if (hr == S_OK)
+			return Utils::ToPathString(path.data());
+		else
+			return EPRO_TEXT("."); // default to working directory
+	}
+}
+
+#endif
 
 namespace ygo {
 
 GameConfig::GameConfig() {
-	Load(EPRO_TEXT("./config/system.conf"));
+#if XDG_ENVIRONMENT
+	{
+#ifndef _WIN32
+		const char* home_env = getenv("HOME");
+		epro::path_string home = Utils::ToPathString(home_env);
+#endif
+
+		const char* data_home = getenv("XDG_DATA_HOME");
+		const char* cache_home = getenv("XDG_CACHE_HOME");
+		const char* config_home = getenv("XDG_CONFIG_HOME");
+
+		if (cache_home)
+			cache_directory = Utils::ToPathString(cache_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			cache_directory = GetSpecialFolder(CSIDL_INTERNET_CACHE) / EPRO_TEXT("ygopro");
+#else
+			cache_directory = home / EPRO_TEXT(".cache/ygopro");
+#endif
+		}
+		if (data_home)
+			data_directory = Utils::ToPathString(data_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			data_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			data_directory = home / EPRO_TEXT(".local/share/ygopro");
+#endif
+		}
+
+		if (config_home)
+			config_directory = Utils::ToPathString(config_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			config_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			config_directory = home / EPRO_TEXT(".config/ygopro");
+#endif
+		}
+
+#ifdef _WIN32
+		sysconfig_directory = EPRO_TEXT("C:/ProjectIgnis");
+		sysdata_directory = EPRO_TEXT("C:/ProjectIgnis");
+#else
+		sysconfig_directory = EPRO_TEXT("/etc/ygopro");
+		sysdata_directory = EPRO_TEXT("/usr/share/ygopro");
+#endif
+	}
+#endif
+	if(!Load(config_directory / EPRO_TEXT("system.conf")))
+		Load(sysconfig_directory / EPRO_TEXT("system.conf"));
+
 	if(configs.empty()) {
 		{
+			auto configs_json = config_directory / EPRO_TEXT("configs.json");
 #if defined(__MINGW32__) && defined(UNICODE)
-			auto fd = _wopen(EPRO_TEXT("./config/configs.json"), _O_RDONLY);
+			auto fd = _wopen(configs_json.data(), _O_RDONLY);
+			if (fd == -1) {
+				configs_json = sysconfig_directory / EPRO_TEXT("configs.json");
+				fd = _wopen(configs_json.data(), _O_RDONLY);
+			}
 			if(fd == -1)
 				goto load_user_conf;
 			__gnu_cxx::stdio_filebuf<char> b(fd, std::ios::in);
 			std::istream conf_file(&b);
 #else
-			std::ifstream conf_file(EPRO_TEXT("./config/configs.json"));
+			std::ifstream conf_file(configs_json);
+			if (!conf_file)
+				conf_file.open(sysconfig_directory / EPRO_TEXT("configs.json"));
 #endif
 			if(!conf_file.fail()) {
 				try {
@@ -39,14 +122,15 @@ GameConfig::GameConfig() {
 		load_user_conf:
 #endif
 		{
+			auto user_configs_json = config_directory / EPRO_TEXT("user_configs.json");
 #if defined(__MINGW32__) && defined(UNICODE)
 			auto fd = _wopen(EPRO_TEXT("./config/user_configs.json"), _O_RDONLY);
 			if(fd == -1)
 				return;
 			__gnu_cxx::stdio_filebuf<char> b(fd, std::ios::in);
 			std::istream user_conf_file(&b);
 #else
-			std::ifstream user_conf_file(EPRO_TEXT("./config/user_configs.json"));
+			std::ifstream user_conf_file(user_configs_json);
 #endif
 			if(!user_conf_file.fail()) {
 				try {
diff --git a/gframe/game_config.h b/gframe/game_config.h
index e9c4d81..2e5aaeb 100644
--- a/gframe/game_config.h
+++ b/gframe/game_config.h
@@ -17,7 +17,13 @@ struct GameConfig
 {
 	GameConfig();
 	bool Load(const epro::path_char* filename);
+	inline bool Load(const epro::path_string& path) {
+		return Load(path.c_str());
+	}
 	bool Save(const epro::path_char* filename);
+	inline bool Save(const epro::path_string& path) {
+		return Save(path.c_str());
+	}
 
 	irr::video::E_DRIVER_TYPE driver_type{ irr::video::EDT_COUNT };
 #if defined(__linux__) && !defined(__ANDROID__) && (IRRLICHT_VERSION_MAJOR==1 && IRRLICHT_VERSION_MINOR==9)
@@ -110,6 +116,13 @@ struct GameConfig
 	epro::path_string locale{ EPRO_TEXT("English") };
 	std::string ssl_certificate_path;
 
+	epro::path_string cache_directory = EPRO_TEXT("./");
+	epro::path_string config_directory = EPRO_TEXT("./config");
+	epro::path_string data_directory = EPRO_TEXT("./");
+
+	epro::path_string sysconfig_directory = EPRO_TEXT("./config");
+	epro::path_string sysdata_directory = EPRO_TEXT("./");
+
 	nlohmann::json configs;
 	nlohmann::json user_configs;
 };
diff --git a/gframe/gframe.cpp b/gframe/gframe.cpp
index 7d20f99..2496607 100644
--- a/gframe/gframe.cpp
+++ b/gframe/gframe.cpp
@@ -232,7 +232,6 @@ int _tmain(int argc, epro::path_char* argv[]) {
 		ygo::gImageDownloader = data->imageDownloader.get();
 		ygo::gDataManager = data->dataManager.get();
 		ygo::gSoundManager = data->sounds.get();
-		ygo::gGameConfig = data->configs.get();
 		ygo::gRepoManager = data->gitManager.get();
 		ygo::gdeckManager = data->deckManager.get();
 	}
diff --git a/gframe/image_downloader.cpp b/gframe/image_downloader.cpp
index 51dab53..69bf1bc 100644
--- a/gframe/image_downloader.cpp
+++ b/gframe/image_downloader.cpp
@@ -123,28 +123,21 @@ void ImageDownloader::DownloadPic() {
 		auto& map_elem = downloading_images[type][code];
 		map_elem.status = downloadStatus::DOWNLOADING;
 		lck.unlock();
-		auto name = fmt::format(EPRO_TEXT("./pics/temp/{}"), code);
+		auto name = gGameConfig->cache_directory / fmt::format(EPRO_TEXT("pics/temp/{}"), code);
 		if(type == imgType::THUMB)
 			type = imgType::ART;
-		epro::path_stringview dest;
-		switch(type) {
-			case imgType::ART:
-			case imgType::THUMB: {
-				dest = EPRO_TEXT("./pics/{}"_sv);
-				break;
-			}
-			case imgType::FIELD: {
-				dest = EPRO_TEXT("./pics/field/{}"_sv);
-				name.append(EPRO_TEXT("_f"));
-				break;
+		auto dest_folder = [type, &name, code]()->epro::path_string {
+			const epro::path_string code_s = fmt::format(EPRO_TEXT("{}"), code);
+			switch(type) {
+				case imgType::ART:
+				case imgType::THUMB:
+					return gGameConfig->cache_directory / EPRO_TEXT("pics") / code_s;
+				case imgType::FIELD:
+					return gGameConfig->cache_directory / EPRO_TEXT("pics/field") / code_s;
+				case imgType::COVER:
+					return gGameConfig->cache_directory / EPRO_TEXT("pics/cover") / code_s;
 			}
-			case imgType::COVER: {
-				dest = EPRO_TEXT("./pics/cover/{}"_sv);
-				name.append(EPRO_TEXT("_c"));
-				break;
-			}
-		}
-		auto dest_folder = fmt::format(dest, code);
+		}();
 		CURLcode res{ static_cast<CURLcode>(1) };
 		for(auto& src : pic_urls) {
 			if(src.type != type)
diff --git a/gframe/image_manager.cpp b/gframe/image_manager.cpp
index 69eb99e..d6bf764 100644
--- a/gframe/image_manager.cpp
+++ b/gframe/image_manager.cpp
@@ -12,15 +12,49 @@
 #include "image_downloader.h"
 #include "game.h"
 
-#define BASE_PATH EPRO_TEXT("./textures/")
+#define BASE_PATH EPRO_TEXT("textures/")
 
 namespace ygo {
+void ImageManager::InitTexture_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = driver->getTexture((textures_path / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path / jpg).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / jpg).c_str());
+	default_texture = texture;
+}
+void ImageManager::InitTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path, uint32_t w, uint32_t h)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = GetTextureFromFile((textures_path / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	default_texture = texture;
+}
+void ImageManager::GetTexture_(irr::video::ITexture*& texture, irr::video::ITexture* default_texture, epro::path_string path)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = driver->getTexture((textures_path / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path / jpg).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / jpg).c_str());
+	if (!texture) texture = default_texture;
+}
+void ImageManager::GetTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture* default_texture, epro::path_string path, uint32_t w, uint32_t h)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = GetTextureFromFile((textures_path / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = default_texture;
+}
+
 
-#define X(x) (textures_path + EPRO_TEXT(x)).data()
-#define GET(obj,fun1,fun2) do {obj=fun1; if(!obj) obj=fun2; def_##obj=obj;}while(0)
-#define GTFF(path,ext,w,h) GetTextureFromFile(X(path ext), mainGame->Scale(w), mainGame->Scale(h))
-#define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h))
-#define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg")))
+#define GET_TEXTURE_SIZED(obj,path,w,h) InitTextureSized_(obj,def_##obj,EPRO_TEXT(path),w,h)
+#define GET_TEXTURE(obj,path) InitTexture_(obj,def_##obj,EPRO_TEXT(path))
 #define CHECK_RETURN(what, name) do { if(!what) { throw std::runtime_error("Couldn't load texture: " name); }} while(0)
 ImageManager::ImageManager() {
 	stop_threads = false;
@@ -43,7 +77,8 @@ ImageManager::~ImageManager() {
 }
 bool ImageManager::Initial() {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
-	textures_path = BASE_PATH;
+	textures_path = gGameConfig->data_directory / BASE_PATH;
+	textures_path2 = gGameConfig->sysdata_directory / BASE_PATH;
 	GET_TEXTURE_SIZED(tCover[0], "cover", CARD_IMG_WIDTH, CARD_IMG_HEIGHT);
 	CHECK_RETURN(tCover[0], "cover");
 	GET_TEXTURE_SIZED(tCover[1], "cover2", CARD_IMG_WIDTH, CARD_IMG_HEIGHT);
@@ -138,21 +173,10 @@ bool ImageManager::Initial() {
 	return true;
 }
 
-#undef GET
 #undef GET_TEXTURE
 #undef GET_TEXTURE_SIZED
-#define GET(to_set,fun1,fun2,fallback) do  {\
-	irr::video::ITexture* tmp = fun1;\
-	if(!tmp)\
-		tmp = fun2;\
-	if(!tmp)\
-		tmp = fallback;\
-	if(to_set != fallback)\
-		driver->removeTexture(to_set);\
-	to_set = tmp;\
-} while(0)
-#define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h),def_##obj)
-#define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg")),def_##obj)
+#define GET_TEXTURE_SIZED(obj,path,w,h) GetTextureSized_(obj,def_##obj,EPRO_TEXT(path),w,h)
+#define GET_TEXTURE(obj,path) GetTexture_(obj,def_##obj,EPRO_TEXT(path))
 void ImageManager::ChangeTextures(epro::path_stringview _path) {
 	if(_path == textures_path)
 		return;
@@ -201,7 +225,7 @@ void ImageManager::ChangeTextures(epro::path_stringview _path) {
 	RefreshCovers();
 }
 void ImageManager::ResetTextures() {
-	ChangeTextures(BASE_PATH);
+	ChangeTextures(gGameConfig->data_directory / BASE_PATH);
 }
 void ImageManager::SetDevice(irr::IrrlichtDevice* dev) {
 	device = dev;
@@ -234,7 +258,6 @@ void ImageManager::ClearTexture(bool resize) {
 }
 #undef GET_TEXTURE
 #undef GET_TEXTURE_SIZED
-#undef X
 void ImageManager::RemoveTexture(uint32_t code) {
 	for(auto map : { &tMap[0], &tMap[1] }) {
 		auto tit = map->find(code);
@@ -296,44 +319,18 @@ void ImageManager::ClearFutureObjects() {
 }
 void ImageManager::RefreshCovers() {
 	irr::video::ITexture* tmp_cover = nullptr;
-#undef GET
-#define GET(obj,fun1,fun2) do {obj=fun1; if(!obj) obj=fun2;} while(0)
-#define X(x) BASE_PATH x
-#define GET_TEXTURE_SIZED(obj,path) do {GET(tmp_cover,GetTextureFromFile(X( path".png"),sizes[1].first,sizes[1].second),GetTextureFromFile(X( path".jpg"),sizes[1].first,sizes[1].second));\
-										if(tmp_cover) {\
-											driver->removeTexture(obj); \
-											obj = tmp_cover;\
-										}} while(0)
+#define GET_TEXTURE_SIZED(obj,path) do {                                \
+		GetTextureSized_(tmp_cover, nullptr, EPRO_TEXT(path),	\
+				 sizes[1].first,sizes[1].second);	\
+		if(tmp_cover) {						\
+			driver->removeTexture(obj);			\
+			obj = tmp_cover;				\
+		}} while (0)
 	GET_TEXTURE_SIZED(tCover[0], "cover");
 	tCover[1] = nullptr;
 	GET_TEXTURE_SIZED(tCover[1], "cover2");
-	if(!tCover[1]) {
-		tCover[1] = tCover[0];
-		def_tCover[1] = tCover[1];
-	}
 	GET_TEXTURE_SIZED(tUnknown, "unknown");
-#undef X
-#define X(x) (textures_path + EPRO_TEXT(x)).data()
-	if(textures_path != BASE_PATH) {
-		GET(tmp_cover, GetTextureFromFile(X("cover.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("cover.jpg"), sizes[1].first, sizes[1].second));
-		if(tmp_cover){
-			driver->removeTexture(tCover[0]);
-			tCover[0] = tmp_cover;
-		}
-		GET(tmp_cover, GetTextureFromFile(X("cover2.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("cover2.jpg"), sizes[1].first, sizes[1].second));
-		if(tmp_cover){
-			driver->removeTexture(tCover[1]);
-			tCover[1] = tmp_cover;
-		}
-		GET(tmp_cover, GetTextureFromFile(X("unknown.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("unknown.jpg"), sizes[1].first, sizes[1].second));
-		if(tmp_cover){
-			driver->removeTexture(tUnknown);
-			tUnknown = tmp_cover;
-		}
-	}
 #undef GET_TEXTURE_SIZED
-#undef GET
-#undef GTFF
 }
 void ImageManager::ClearCachedTextures(bool resize) {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
diff --git a/gframe/image_manager.h b/gframe/image_manager.h
index 620f48a..3f82fef 100644
--- a/gframe/image_manager.h
+++ b/gframe/image_manager.h
@@ -102,10 +102,15 @@ public:
 	A(tSettings)
 #undef A
 private:
+	void GetTexture_(irr::video::ITexture*& texture, irr::video::ITexture* fallback, epro::path_string path);
+	void GetTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture* fallback, epro::path_string path, uint32_t w, uint32_t h);
+	void InitTexture_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path);
+	void InitTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path, uint32_t w, uint32_t h);
 	void ClearFutureObjects();
 	void RefreshCovers();
 	image_path LoadCardTexture(uint32_t code, imgType type, std::atomic<irr::s32>& width, std::atomic<irr::s32>& height, chrono_time timestamp_id, std::atomic<chrono_time>& source_timestamp_id);
 	epro::path_string textures_path;
+	epro::path_string textures_path2;
 	std::pair<std::atomic<irr::s32>, std::atomic<irr::s32>> sizes[3];
 	std::atomic<chrono_time> timestamp_id;
 	std::mutex obj_clear_lock;
diff --git a/gframe/premake5.lua b/gframe/premake5.lua
index 15891d6..fdf8fa0 100644
--- a/gframe/premake5.lua
+++ b/gframe/premake5.lua
@@ -30,6 +30,9 @@ local ygopro_config=function(static_core)
 	if _OPTIONS["environment-paths"] then
 		defines { "YGOPRO_ENVIRONMENT_PATHS" }
 	end
+	if _OPTIONS["xdg-environment"] then
+		defines { "XDG_ENVIRONMENT" }
+	end
 
 	includedirs "../ocgcore"
 	links { "clzma", "freetype", "Irrlicht" }
diff --git a/gframe/replay.cpp b/gframe/replay.cpp
index d7ba888..01818d3 100644
--- a/gframe/replay.cpp
+++ b/gframe/replay.cpp
@@ -4,6 +4,7 @@
 #include <fmt/format.h>
 #include "lzma/LzmaLib.h"
 #include "common.h"
+#include "game_config.h"
 #include "utils.h"
 #if defined(__MINGW32__) && defined(UNICODE)
 #include <fcntl.h>
@@ -100,7 +101,8 @@ void Replay::EndRecord(size_t size) {
 	is_recording = false;
 }
 void Replay::SaveReplay(const epro::path_string& name) {
-	auto replay_file = fileopen(fmt::format(EPRO_TEXT("./replay/{}.yrpX"), name).data(), "wb");
+	auto replay_file_name = gGameConfig->data_directory / fmt::format(EPRO_TEXT("replay/{}.yrpX"), name);
+	auto replay_file = fileopen(replay_file_name.data(), "wb");
 	if(replay_file == nullptr)
 		return;
 	fwrite(&pheader, 1, sizeof(pheader), replay_file);
@@ -166,7 +168,7 @@ bool Replay::OpenReplay(const epro::path_string& name) {
 #else
 	std::ifstream replay_file(name, std::ifstream::binary);
 	if(replay_file.fail()) {
-		replay_file.open(EPRO_TEXT("./replay/") + name, std::ifstream::binary);
+		replay_file.open(gGameConfig->data_directory / EPRO_TEXT("replay/") + name, std::ifstream::binary);
 		if(replay_file.fail()) {
 			replay_name.clear();
 			return false;
diff --git a/gframe/single_mode.cpp b/gframe/single_mode.cpp
index 0ff775a..7e50634 100644
--- a/gframe/single_mode.cpp
+++ b/gframe/single_mode.cpp
@@ -148,7 +148,7 @@ restart:
 		if(open_file) {
 			script_name = Utils::ToUTF8IfNeeded(open_file_name);
 			if(!mainGame->LoadScript(pduel, script_name)) {
-				script_name = fmt::format("./puzzles/{}" ,script_name);
+				script_name = Utils::ToUTF8IfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles") / open_file_name);
 				loaded = mainGame->LoadScript(pduel, script_name);
 			}
 		} else {
diff --git a/gframe/sound_manager.cpp b/gframe/sound_manager.cpp
index 2e849bc..ebc9c10 100644
--- a/gframe/sound_manager.cpp
+++ b/gframe/sound_manager.cpp
@@ -53,15 +53,15 @@ bool SoundManager::IsUsable() {
 }
 void SoundManager::RefreshBGMList() {
 #ifdef BACKEND
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/duel"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/menu"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/deck"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/advantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/disadvantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/win"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/lose"));
-	for (auto& list : BGMList)
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/duel"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/menu"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/deck"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/advantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/disadvantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/win"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/lose"));
+	for (auto list : BGMList)
 		list.clear();
 	RefreshBGMDir(EPRO_TEXT(""), BGM::DUEL);
 	RefreshBGMDir(EPRO_TEXT("duel"), BGM::DUEL);
@@ -80,35 +80,35 @@ void SoundManager::RefreshSoundsList() {
 #else
 	static constexpr std::pair<SFX, epro::path_stringview> fx[] = {
 #endif
-		{SUMMON, EPRO_TEXT("./sound/summon.{}")},
-		{SPECIAL_SUMMON, EPRO_TEXT("./sound/specialsummon.{}")},
-		{ACTIVATE, EPRO_TEXT("./sound/activate.{}")},
-		{SET, EPRO_TEXT("./sound/set.{}")},
-		{FLIP, EPRO_TEXT("./sound/flip.{}")},
-		{REVEAL, EPRO_TEXT("./sound/reveal.{}")},
-		{EQUIP, EPRO_TEXT("./sound/equip.{}")},
-		{DESTROYED, EPRO_TEXT("./sound/destroyed.{}")},
-		{BANISHED, EPRO_TEXT("./sound/banished.{}")},
-		{TOKEN, EPRO_TEXT("./sound/token.{}")},
-		{ATTACK, EPRO_TEXT("./sound/attack.{}")},
-		{DIRECT_ATTACK, EPRO_TEXT("./sound/directattack.{}")},
-		{DRAW, EPRO_TEXT("./sound/draw.{}")},
-		{SHUFFLE, EPRO_TEXT("./sound/shuffle.{}")},
-		{DAMAGE, EPRO_TEXT("./sound/damage.{}")},
-		{RECOVER, EPRO_TEXT("./sound/gainlp.{}")},
-		{COUNTER_ADD, EPRO_TEXT("./sound/addcounter.{}")},
-		{COUNTER_REMOVE, EPRO_TEXT("./sound/removecounter.{}")},
-		{COIN, EPRO_TEXT("./sound/coinflip.{}")},
-		{DICE, EPRO_TEXT("./sound/diceroll.{}")},
-		{NEXT_TURN, EPRO_TEXT("./sound/nextturn.{}")},
-		{PHASE, EPRO_TEXT("./sound/phase.{}")},
-		{PLAYER_ENTER, EPRO_TEXT("./sound/playerenter.{}")},
-		{CHAT, EPRO_TEXT("./sound/chatmessage.{}")}
+		{SUMMON, EPRO_TEXT("sound/summon.{}")},
+		{SPECIAL_SUMMON, EPRO_TEXT("sound/specialsummon.{}")},
+		{ACTIVATE, EPRO_TEXT("sound/activate.{}")},
+		{SET, EPRO_TEXT("sound/set.{}")},
+		{FLIP, EPRO_TEXT("sound/flip.{}")},
+		{REVEAL, EPRO_TEXT("sound/reveal.{}")},
+		{EQUIP, EPRO_TEXT("sound/equip.{}")},
+		{DESTROYED, EPRO_TEXT("sound/destroyed.{}")},
+		{BANISHED, EPRO_TEXT("sound/banished.{}")},
+		{TOKEN, EPRO_TEXT("sound/token.{}")},
+		{ATTACK, EPRO_TEXT("sound/attack.{}")},
+		{DIRECT_ATTACK, EPRO_TEXT("sound/directattack.{}")},
+		{DRAW, EPRO_TEXT("sound/draw.{}")},
+		{SHUFFLE, EPRO_TEXT("sound/shuffle.{}")},
+		{DAMAGE, EPRO_TEXT("sound/damage.{}")},
+		{RECOVER, EPRO_TEXT("sound/gainlp.{}")},
+		{COUNTER_ADD, EPRO_TEXT("sound/addcounter.{}")},
+		{COUNTER_REMOVE, EPRO_TEXT("sound/removecounter.{}")},
+		{COIN, EPRO_TEXT("sound/coinflip.{}")},
+		{DICE, EPRO_TEXT("sound/diceroll.{}")},
+		{NEXT_TURN, EPRO_TEXT("sound/nextturn.{}")},
+		{PHASE, EPRO_TEXT("sound/phase.{}")},
+		{PLAYER_ENTER, EPRO_TEXT("sound/playerenter.{}")},
+		{CHAT, EPRO_TEXT("sound/chatmessage.{}")}
 	};
 	const auto extensions = mixer->GetSupportedSoundExtensions();
 	for(const auto& sound : fx) {
 		for(const auto& ext : extensions) {
-			const auto filename = fmt::format(sound.second, ext);
+			const auto filename = Utils::ToPathString(working_dir) / fmt::format(sound.second, ext);
 			if(Utils::FileExists(filename)) {
 				SFXList[sound.first] = Utils::ToUTF8IfNeeded(filename);
 				break;
@@ -119,7 +119,7 @@ void SoundManager::RefreshSoundsList() {
 }
 void SoundManager::RefreshBGMDir(epro::path_stringview path, BGM scene) {
 #ifdef BACKEND
-	for(auto& file : Utils::FindFiles(fmt::format(EPRO_TEXT("./sound/BGM/{}"), path), mixer->GetSupportedMusicExtensions())) {
+	for(auto& file : Utils::FindFiles(Utils::ToPathString(working_dir) / fmt::format(EPRO_TEXT("sound/BGM/{}"), path), mixer->GetSupportedMusicExtensions())) {
 		auto conv = Utils::ToUTF8IfNeeded(fmt::format(EPRO_TEXT("{}/{}"), path, file));
 		BGMList[BGM::ALL].push_back(conv);
 		BGMList[scene].push_back(std::move(conv));
diff --git a/gframe/utils.cpp b/gframe/utils.cpp
index 18548be..722b685 100644
--- a/gframe/utils.cpp
+++ b/gframe/utils.cpp
@@ -1,10 +1,13 @@
 #include "utils.h"
+#include "game_config.h"
 #include <cmath> // std::round
 #include <fstream>
 #ifdef _WIN32
 #define WIN32_LEAN_AND_MEAN
 #include <Windows.h>
 #include <shellapi.h> // ShellExecute
+#include <shlwapi.h> // PathIsRelative{,A,W}
+#undef PathIsRelative
 #else
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
@@ -31,6 +34,8 @@ using Stat = struct stat;
 #endif //_WIN32
 #include <IFileArchive.h>
 #include <IFileSystem.h>
+#include <iostream>
+#include <sstream>
 #include <fmt/format.h>
 #include <IOSOperator.h>
 #include "config.h"
@@ -61,6 +66,15 @@ static inline void NameThread(const char* threadName) {
 	__try {	RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info); }
 	__except(EXCEPTION_EXECUTE_HANDLER) {}
 }
+
+bool PathIsRelative(const epro::path_char* path)
+{
+#ifdef UNICODE
+	return PathIsRelativeW(path);
+#else
+	return PathIsRelativeA(path);
+#endif
+}
 }
 #pragma warning(pop)
 #endif
@@ -89,6 +103,14 @@ namespace ygo {
 #endif //_WIN32
 	}
 
+	bool Utils::PathIsRelative(epro::path_stringview path) {
+#ifdef _WIN32
+		return PathIsRelativeW(ToUnicodeIfNeeded(path).data());
+#else
+		return path[0] != EPRO_TEXT('/');
+#endif
+	}
+
 	bool Utils::MakeDirectory(epro::path_stringview path) {
 #ifdef _WIN32
 		return CreateDirectory(path.data(), nullptr) || ERROR_ALREADY_EXISTS == GetLastError();
@@ -227,15 +249,19 @@ namespace ygo {
 
 	void Utils::CreateResourceFolders() {
 		//create directories if missing
-		MakeDirectory(EPRO_TEXT("deck"));
-		MakeDirectory(EPRO_TEXT("puzzles"));
-		MakeDirectory(EPRO_TEXT("pics"));
-		MakeDirectory(EPRO_TEXT("pics/field"));
-		MakeDirectory(EPRO_TEXT("pics/cover"));
-		MakeDirectory(EPRO_TEXT("pics/temp/"));
-		ClearDirectory(EPRO_TEXT("pics/temp/"));
-		MakeDirectory(EPRO_TEXT("replay"));
-		MakeDirectory(EPRO_TEXT("screenshots"));
+		MakeDirectory(gGameConfig->config_directory);
+		MakeDirectory(gGameConfig->data_directory);
+		MakeDirectory(gGameConfig->cache_directory);
+
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("deck"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("puzzles"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/field"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/cover"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		ClearDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("replay"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("screenshots"));
 	}
 
 	std::vector<epro::path_string> Utils::FindFiles(epro::path_stringview path, const std::vector<epro::path_stringview>& extensions, int subdirectorylayers) {
diff --git a/gframe/utils.h b/gframe/utils.h
index 1a6a9af..00f7bae 100644
--- a/gframe/utils.h
+++ b/gframe/utils.h
@@ -54,6 +54,7 @@ namespace ygo {
 		static irr::io::IFileSystem* filesystem;
 		static irr::IOSOperator* OSOperator;
 		static epro::path_string working_dir;
+		static bool PathIsRelative(epro::path_stringview path);
 		static bool MakeDirectory(epro::path_stringview path);
 #ifdef __linux__
 		static bool FileCopyFD(int source, int destination);
diff --git a/gframe/utils_gui.cpp b/gframe/utils_gui.cpp
index fa1e383..7ee9415 100644
--- a/gframe/utils_gui.cpp
+++ b/gframe/utils_gui.cpp
@@ -191,7 +191,7 @@ bool GUIUtils::TakeScreenshot(irr::IrrlichtDevice* device) {
 	if(!image)
 		return false;
 	const auto now = std::time(nullptr);
-	const auto filename = fmt::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now));
+	const auto filename = gGameConfig->data_directory / fmt::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now));
 	auto written = driver->writeImageToFile(image, { filename.data(), static_cast<irr::u32>(filename.size()) });
 	if(!written)
 		device->getLogger()->log(L"Failed to take screenshot.", irr::ELL_WARNING);
@@ -337,7 +337,7 @@ void GUIUtils::ShowErrorWindow(epro::stringview context, epro::stringview messag
 		nullptr, //icon url, use default, you can change it depending message_type flags
 		nullptr, //not used
 		nullptr, //localization of strings
-		header_ref, //header text 
+		header_ref, //header text
 		message_ref, //message text
 		nullptr, //default "ok" text in button
 		nullptr, //alternate button title
diff --git a/premake5.lua b/premake5.lua
index e76e8f1..31e003f 100644
--- a/premake5.lua
+++ b/premake5.lua
@@ -64,6 +64,11 @@ newoption {
 	trigger = "environment-paths",
 	description = "Read databases, scripts and images from YGOPRO_*_PATH"
 }
+newoption
+{
+	trigger = "xdg-environment",
+	description = "Use XDG config, data and cache directories."
+}
 workspace "ygo"
 	location "build"
 	language "C++"
--
libgit2 1.1.0

