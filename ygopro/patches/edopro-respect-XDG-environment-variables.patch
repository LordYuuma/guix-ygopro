From f64b9d66fb532e32ecede65aba593894081cb6fb Mon Sep 17 00:00:00 2001
From: LordYuuma <lordyuuma@gmail.com>
Date: Thu, 9 Apr 2020 18:52:34 +0200
Subject: [PATCH] edopro: Respect XDG environment variables.

* premake5.lua: (xdg-environment): New option.
* gframe/premake5.lua [xdg-environment]: Define XDG_ENVIRONMENT.
* gframe/data_handler.cpp (DataHandler):
Initialize gGameConfig early.
Load strings from config_directory, falling back to sysconfig_directory.
* gframe/deck_manager.cpp (LoadLFList): Load LFLists from data_directory.
(LoadDeck, LoadDeckDouble, DeleteDeck, RenameDeck): Use data_directory.
* gframe/game.cpp (Initialize): Load skins, replays and singles from
data_directory.
(ApplySkin): Load textures from data_directory.
(RefreshDeck): Load decks from data_directory.
(SaveConfig): Save config in config_directory.
(LoadScript): Allow absolute paths.
(PopulateResourceDirectories): Use data_directory and cache_directory
for pics.
(PopulateResourceDirectories)[!YGOPRO_ENVIRONMENT_PATHS]: Use data_directory
for scripts.
(PopulateLocales): Use config_directory.
* gframe/game_config.cpp [XDG_ENVIRONMENT,_WIN32](GetSpecialFolder): New
procedure.
(GameConfig)[XDG_ENVIRONMENT]: Initialize
cache_directory, config_directory, and data_directory according to
environment.  Set sane values for sysconfig_directory and
sysdata_directory.
(GameConfig): Load conf_file from config_directory, defaulting to
sysconfig_directory.
* gframe/game_config.h (Load,Save): Add path_string& overloads.
(cache_directory,config_directory,data_directory)
(sysconfig_directory,sysdata_directory): New fields.
* gframe/gframe.cpp (main): Don't set gGameConfig, already done.
* gframe/image_downloader.cpp (DownloadPic): Use cache_directory.
* gframe/image_manager.h: (textures_path2): New field.
(InitTexture_,InitTextureSized_,GetTexture_,GetTextureSized_): New helpers.
* gframe/image_manager.cpp (Initial): Initialize textures_path with
data_directory and textures_path2 with sysdata_directory.
(InitTexture_,InitTextureSized_,GetTexture_,GetTextureSized_): Implement.
(X,GET): Removed macro.
(GET_TEXTURE_SIZED,GET_TEXTURE): Implement in terms of InitTextureSized_,
InitTexture_, GetTextureSized_ and GetTexture_.
(RefreshCovers): Refactor away some duplicate operations now that we have
textures_path2.
* gframe/replay.cpp (BeginRecord,SaveReplay,OpenReplay): Load replays
from data_directory.
* gframe/sound_manager.cpp (RefreshBGMList,RefreshBGMDir): Properly expand
working_directory.
* gframe/utils.h (PathIsRelative): New procedure.
* gframe/utils.cpp (PathIsRelative): Implement it.
(CreateResourceFolders): Create config_directory, data_directory and
cache_directory.
Create pics structure in cache_directory, create deck, puzzles, replay
and screenshots folder in data_directory.
* gframe/utils_gui.cpp (TakeScreenshot): Save in data_directory.
---
 gframe/data_handler.cpp     |  8 ++--
 gframe/deck_manager.cpp     | 20 +++++----
 gframe/game.cpp             | 82 +++++++++++++++++++-----------------
 gframe/game_config.cpp      | 84 +++++++++++++++++++++++++++++++++++--
 gframe/game_config.h        | 13 ++++++
 gframe/gframe.cpp           |  1 -
 gframe/image_downloader.cpp |  9 ++--
 gframe/image_manager.cpp    | 76 +++++++++++++++++++--------------
 gframe/image_manager.h      |  5 +++
 gframe/premake5.lua         |  3 ++
 gframe/replay.cpp           |  7 ++--
 gframe/single_mode.cpp      |  2 +-
 gframe/sound_manager.cpp    | 18 ++++----
 gframe/utils.cpp            | 52 ++++++++++++++++++-----
 gframe/utils.h              |  1 +
 gframe/utils_gui.cpp        |  3 +-
 premake5.lua                |  5 +++
 17 files changed, 275 insertions(+), 114 deletions(-)

diff --git a/gframe/data_handler.cpp b/gframe/data_handler.cpp
index e40b750d..823b246a 100644
--- a/gframe/data_handler.cpp
+++ b/gframe/data_handler.cpp
@@ -109,6 +109,7 @@ void DataHandler::LoadZipArchives() {
 }
 DataHandler::DataHandler() {
 	configs = std::unique_ptr<GameConfig>(new GameConfig);
+	gGameConfig = configs.get();
 	tmp_device = nullptr;
 #ifndef __ANDROID__
 	tmp_device = GUIUtils::CreateDevice(configs.get());
@@ -121,7 +122,7 @@ DataHandler::DataHandler() {
 #ifdef __ANDROID__
 	configs->working_directory = porting::working_directory;
 #endif
-	sounds = std::unique_ptr<SoundManager>(new SoundManager(configs->soundVolume / 100.0, configs->musicVolume / 100.0, configs->enablesound, configs->enablemusic / 100.0, configs->working_directory));
+	sounds = std::unique_ptr<SoundManager>(new SoundManager(configs->soundVolume / 100.0, configs->musicVolume / 100.0, configs->enablesound, configs->enablemusic / 100.0, configs->data_directory));
 	gitManager->LoadRepositoriesFromJson(configs->user_configs);
 	gitManager->LoadRepositoriesFromJson(configs->configs);
 	dataManager = std::unique_ptr<DataManager>(new DataManager());
@@ -129,8 +130,9 @@ DataHandler::DataHandler() {
 	LoadDatabases();
 	LoadPicUrls();
 	deckManager->LoadLFList();
-	auto strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./config/strings.conf"));
-	strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./expansions/strings.conf")) || strings_loaded;
+	auto strings_loaded = dataManager->LoadStrings(configs->config_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = strings_loaded || dataManager->LoadStrings(configs->sysconfig_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = dataManager->LoadStrings(configs->data_directory / EPRO_TEXT("expansions/strings.conf")) || strings_loaded;
 	if(!strings_loaded) {
 		throw std::runtime_error("Failed to load strings!");
 	}
diff --git a/gframe/deck_manager.cpp b/gframe/deck_manager.cpp
index 797f2d2b..92295f59 100644
--- a/gframe/deck_manager.cpp
+++ b/gframe/deck_manager.cpp
@@ -1,3 +1,4 @@
+#include "game_config.h"
 #include "network.h"
 #include "deck_manager.h"
 #include "data_manager.h"
@@ -74,9 +75,9 @@ bool DeckManager::LoadLFListFolder(path_string path) {
 }
 void DeckManager::LoadLFList() {
 #ifndef YGOPRO_ENVIRONMENT_PATHS
-	LoadLFListSingle(EPRO_TEXT("./expansions/lflist.conf"));
-	LoadLFListSingle(EPRO_TEXT("./lflist.conf"));
-	LoadLFListFolder(EPRO_TEXT("./lflists/"));
+	LoadLFListSingle(gGameConfig->data_directory / EPRO_TEXT("expansions/lflist.conf"));
+	LoadLFListSingle(gGameConfig->data_directory / EPRO_TEXT("lflist.conf"));
+	LoadLFListFolder(gGameConfig->data_directory / EPRO_TEXT("lflists/"));
 #endif
 	LFList nolimit;
 	nolimit.listName = L"N/A"; // N/A
@@ -351,7 +352,7 @@ bool DeckManager::LoadSide(Deck& deck, int* dbuf, int mainc, int sidec) {
 bool DeckManager::LoadDeck(const path_string& file, Deck* deck) {
 	std::vector<int> mainlist;
 	std::vector<int> sidelist;
-	if(!LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist)) {
+	if(!LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist)) {
 		if(!LoadCardList(file, &mainlist, &sidelist))
 			return false;
 	}
@@ -364,8 +365,8 @@ bool DeckManager::LoadDeck(const path_string& file, Deck* deck) {
 bool DeckManager::LoadDeckDouble(const path_string& file, const path_string& file2, Deck* deck) {
 	std::vector<int> mainlist;
 	std::vector<int> sidelist;
-	LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist);
-	LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file2.c_str()), &mainlist, &sidelist);
+	LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), file.c_str()), &mainlist, &sidelist);
+	LoadCardList(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), file2.c_str()), &mainlist, &sidelist);
 	if(deck)
 		LoadDeck(*deck, mainlist, sidelist);
 	else
@@ -373,7 +374,7 @@ bool DeckManager::LoadDeckDouble(const path_string& file, const path_string& fil
 	return true;
 }
 bool DeckManager::SaveDeck(Deck& deck, const path_string& name) {
-	std::ofstream deckfile(fmt::format(EPRO_TEXT("./deck/{}.ydk"), name.c_str()), std::ofstream::out);
+	std::ofstream deckfile(fmt::format(gGameConfig->data_directory / EPRO_TEXT("./deck/{}.ydk"), name.c_str()), std::ofstream::out);
 	if(!deckfile.is_open())
 		return false;
 	deckfile << "#created by " << BufferIO::EncodeUTF8s(mainGame->ebNickName->getText()) << "\n#main\n";
@@ -493,9 +494,10 @@ void DeckManager::ImportDeckBase64(Deck& deck, const wchar_t* buffer) {
 	LoadDeck(deck, (int*)deck_data.data(), mainc, sidec);
 }
 bool DeckManager::DeleteDeck(Deck& deck, const path_string& name) {
-	return Utils::FileDelete(fmt::format(EPRO_TEXT("./deck/{}.ydk"), name.c_str()));
+	return Utils::FileDelete(fmt::format(gGameConfig->data_directory / EPRO_TEXT("deck/{}.ydk"), name.c_str()));
 }
 bool DeckManager::RenameDeck(const path_string& oldname, const path_string& newname) {
-	return Utils::FileMove(EPRO_TEXT("./deck/") + oldname + EPRO_TEXT(".ydk"), EPRO_TEXT("./deck/") + newname + EPRO_TEXT(".ydk"));
+	path_string deck = gGameConfig->data_directory / EPRO_TEXT("deck");
+	return Utils::FileMove(deck / oldname + EPRO_TEXT(".ydk"), deck / newname + EPRO_TEXT(".ydk"));
 }
 }
diff --git a/gframe/game.cpp b/gframe/game.cpp
index f1b3e2a0..2facfb17 100644
--- a/gframe/game.cpp
+++ b/gframe/game.cpp
@@ -95,7 +95,7 @@ bool Game::Initialize() {
 	if(!(ocgcore = LoadOCGcore(gGameConfig->working_directory + EPRO_TEXT("./"))) && !(ocgcore = LoadOCGcore(gGameConfig->working_directory + EPRO_TEXT("./expansions/"))))
 		coreloaded = false;
 #endif
-	skinSystem = new CGUISkinSystem((gGameConfig->working_directory + EPRO_TEXT("./skin")).c_str(), device);
+	skinSystem = new CGUISkinSystem((gGameConfig->data_directory / EPRO_TEXT("skin")).c_str(), device);
 	if(!skinSystem)
 		ErrorLog("Couldn't create skin system");
 	linePatternD3D = 0;
@@ -1133,7 +1133,7 @@ bool Game::Initialize() {
 	wReplay->getCloseButton()->setVisible(false);
 	wReplay->setVisible(false);
 	lstReplayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wReplay, LISTBOX_REPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
-	lstReplayList->setWorkingPath(L"./replay", true);
+	lstReplayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("replay")), true);
 	lstReplayList->addFilteredExtensions(coreloaded ? std::vector<std::wstring>{L"yrp", L"yrpx"} : std::vector<std::wstring>{ L"yrpx" });
 	lstReplayList->setItemHeight(Scale(18));
 	btnLoadReplay = env->addButton(Scale(470, 355, 570, 380), wReplay, BUTTON_LOAD_REPLAY, gDataManager->GetSysString(1348).c_str());
@@ -1170,7 +1170,7 @@ bool Game::Initialize() {
 	wSinglePlay->setVisible(false);
 	lstSinglePlayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wSinglePlay, LISTBOX_SINGLEPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
 	lstSinglePlayList->setItemHeight(Scale(18));
-	lstSinglePlayList->setWorkingPath(L"./puzzles", true);
+	lstSinglePlayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles")), true);
 	lstSinglePlayList->addFilteredExtensions({L"lua"});
 	btnLoadSinglePlay = env->addButton(Scale(460, 355, 570, 380), wSinglePlay, BUTTON_LOAD_SINGLEPLAY, gDataManager->GetSysString(1357).c_str());
 	defaultStrings.emplace_back(btnLoadSinglePlay, 1357);
@@ -1552,7 +1552,7 @@ bool Game::MainLoop() {
 						it->second.push_back(data_path);
 						ReloadElementsStrings();
 					} else {
-						Utils::MakeDirectory(EPRO_TEXT("./config/languages/") + langpath);
+						Utils::MakeDirectory(gGameConfig->config_directory / EPRO_TEXT("languages/") + langpath);
 						locales.emplace_back(langpath, std::vector<path_string>{ data_path });
 						gSettings.cbCurrentLocale->addItem(BufferIO::DecodeUTF8s(repo->language).c_str());
 					}
@@ -1890,7 +1890,7 @@ bool Game::ApplySkin(const path_string& skinname, bool reload, bool firstrun) {
 #include "custom_skin_enum.inl"
 #undef DECLR
 #undef CLR
-		imageManager.ChangeTextures(EPRO_TEXT("./skin/") + prev_skin + EPRO_TEXT("/textures/"));
+		imageManager.ChangeTextures(gGameConfig->data_directory / EPRO_TEXT("skin/") + prev_skin + EPRO_TEXT("/textures/"));
 		} else {
 			applied = false;
 			auto skin = env->createSkin(irr::gui::EGST_WINDOWS_METALLIC);
@@ -1934,7 +1934,7 @@ bool Game::ApplySkin(const path_string& skinname, bool reload, bool firstrun) {
 }
 void Game::RefreshDeck(irr::gui::IGUIComboBox* cbDeck) {
 	cbDeck->clear();
-	for(auto& file : Utils::FindFiles(EPRO_TEXT("./deck/"), { EPRO_TEXT("ydk") })) {
+	for(auto& file : Utils::FindFiles(gGameConfig->data_directory / EPRO_TEXT("deck/"), { EPRO_TEXT("ydk") })) {
 		cbDeck->addItem(Utils::ToUnicodeIfNeeded(file.substr(0, file.size() - 4)).c_str());
 	}
 	for(size_t i = 0; i < cbDeck->getItemCount(); ++i) {
@@ -2058,7 +2058,7 @@ void Game::SaveConfig() {
 #ifdef UPDATE_URL
 	gGameConfig->noClientUpdates = gSettings.chkUpdates->isChecked();
 #endif
-	gGameConfig->Save(EPRO_TEXT("./config/system.conf"));
+	gGameConfig->Save(gGameConfig->config_directory / EPRO_TEXT("system.conf"));
 }
 Game::RepoGui* Game::AddGithubRepositoryStatusWindow(const GitRepo* repo) {
 	std::wstring name = BufferIO::DecodeUTF8s(repo->repo_name);
@@ -3142,20 +3142,24 @@ std::vector<char> Game::LoadScript(const std::string& _name) {
 	std::vector<char> buffer;
 	std::ifstream script;
 	path_string name = Utils::ToPathString(_name);
-	for(auto& path : script_dirs) {
-		if(path == EPRO_TEXT("archives")) {
-			auto lockedIrrFile = Utils::FindFileInArchives(EPRO_TEXT("script/"), name);
-			if(!lockedIrrFile)
-				continue;
-			buffer.resize(lockedIrrFile.reader->getSize());
-			if (lockedIrrFile.reader->read(buffer.data(), buffer.size()) == buffer.size())
-				return buffer;
-		} else {
-			script.open(path + name, std::ifstream::binary);
-			if(script.is_open())
-				break;
+	if (!Utils::PathIsRelative(name))
+		script.open(name, std::ifstream::binary);
+	else
+		for(auto& path : script_dirs) {
+			if(path == EPRO_TEXT("archives")) {
+				auto lockedIrrFile = Utils::FindFileInArchives(EPRO_TEXT("script/"), name);
+				if(!lockedIrrFile)
+					continue;
+				buffer.resize(lockedIrrFile.reader->getSize());
+				if (lockedIrrFile.reader->read(buffer.data(), buffer.size()) == buffer.size())
+					return buffer;
+
+			} else {
+				script.open(path + name, std::ifstream::binary);
+				if(script.is_open())
+					break;
+			}
 		}
-	}
 	if(!script.is_open()) {
 		script.open(name, std::ifstream::binary);
 		if(!script.is_open())
@@ -3248,32 +3252,32 @@ void Game::PopulateResourcesDirectories() {
 				cover_dirs.push_back(image_dir / EPRO_TEXT("cover/"));
 				field_dirs.push_back(image_dir / EPRO_TEXT("field/"));
 			});
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
 #else
-	script_dirs.push_back(EPRO_TEXT("./expansions/script/"));
-	auto expansions_subdirs = Utils::FindSubfolders(EPRO_TEXT("./expansions/script/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	auto expansions_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
 	script_dirs.insert(script_dirs.end(), expansions_subdirs.begin(), expansions_subdirs.end());
-	script_dirs.push_back(EPRO_TEXT("archives"));
-	script_dirs.push_back(EPRO_TEXT("./script/"));
-	auto script_subdirs = Utils::FindSubfolders(EPRO_TEXT("./script/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	auto script_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./script/"));
 	script_dirs.insert(script_dirs.end(), script_subdirs.begin(), script_subdirs.end());
-	pic_dirs.push_back(EPRO_TEXT("./expansions/pics/"));
-	pic_dirs.push_back(EPRO_TEXT("archives"));
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./expansions/pics/cover/"));
-	cover_dirs.push_back(EPRO_TEXT("archives"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./expansions/pics/field/"));
-	field_dirs.push_back(EPRO_TEXT("archives"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/cover/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/field/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
 #endif
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/field/"));
+	pic_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/field/"));
 }
 
 void Game::PopulateLocales() {
 	locales.clear();
-	for(auto& locale : Utils::FindSubfolders(EPRO_TEXT("./config/languages/"), 1, false)) {
+	for(auto& locale : Utils::FindSubfolders(gGameConfig->config_directory / EPRO_TEXT("languages/"), 1, false)) {
 		locales.emplace_back(locale, std::vector<path_string>());
 	}
 }
@@ -3290,7 +3294,7 @@ void Game::ApplyLocale(int index, bool forced) {
 	if(index > 0) {
 		try {
 			gGameConfig->locale = locales[index - 1].first;
-			auto locale = fmt::format(EPRO_TEXT("./config/languages/{}"), gGameConfig->locale);
+			auto locale = fmt::format(gGameConfig->config_directory / EPRO_TEXT("languages/{}"), gGameConfig->locale);
 			for(auto& file : Utils::FindFiles(locale, { EPRO_TEXT("cdb") })) {
 				gDataManager->LoadLocaleDB(fmt::format(EPRO_TEXT("{}/{}"), locale, file));
 			}
diff --git a/gframe/game_config.cpp b/gframe/game_config.cpp
index 483468f8..9a348299 100644
--- a/gframe/game_config.cpp
+++ b/gframe/game_config.cpp
@@ -2,13 +2,91 @@
 #include <fstream>
 #include "config.h"
 #include "logging.h"
+#if XDG_ENVIRONMENT && _WIN32
+#include <Shlobj.h>
+#include <Shlobj_core.h>
+
+namespace
+{
+    path_string
+    GetSpecialFolder (int csidl)
+    {
+	std::vector<wchar_t> path;
+	HRESULT hr;
+	LPITEMIDLIST pidl = NULL;
+	BOOL b;
+	path_string result;
+	path.reserve(MAX_PATH+1);
+
+	hr = SHGetFolderPathA (NULL, csidl, NULL, 0, path.data());
+	if (hr == S_OK)
+	    return Utils::ToPathString(path.data());
+	else
+	    return EPRO_TEXT("."); // default to working directory
+    }
+}
+
+#endif
 
 namespace ygo {
 
 GameConfig::GameConfig() {
-	Load(EPRO_TEXT("./config/system.conf"));
+#if XDG_ENVIRONMENT
+	{
+#ifndef _WIN32
+		const char* home_env = getenv("HOME");
+		path_string home = Utils::ToPathString(home_env);
+#endif
+
+		const char* data_home = getenv("XDG_DATA_HOME");
+		const char* cache_home = getenv("XDG_CACHE_HOME");
+		const char* config_home = getenv("XDG_CONFIG_HOME");
+
+		if (cache_home)
+			cache_directory = Utils::ToPathString(cache_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			cache_directory = GetSpecialFolder(CSIDL_INTERNET_CACHE) / EPRO_TEXT("ygopro");
+#else
+			cache_directory = home / EPRO_TEXT(".cache/ygopro");
+#endif
+		}
+		if (data_home)
+			data_directory = Utils::ToPathString(data_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			data_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			data_directory = home / EPRO_TEXT(".local/share/ygopro");
+#endif
+		}
+
+		if (config_home)
+			config_directory = Utils::ToPathString(config_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			config_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			config_directory = home / EPRO_TEXT(".config/ygopro");
+#endif
+		}
+
+#ifdef _WIN32
+		sysconfig_directory = EPRO_TEXT("C:/ProjectIgnis");
+		sysdata_directory = EPRO_TEXT("C:/ProjectIgnis");
+#else
+		sysconfig_directory = EPRO_TEXT("/etc/ygopro");
+		sysdata_directory = EPRO_TEXT("/usr/share/ygopro");
+#endif
+	}
+#endif
+	if(!Load(config_directory / EPRO_TEXT("system.conf")))
+		Load(sysconfig_directory / EPRO_TEXT("system.conf"));
+
 	if(configs.empty()) {
-		std::ifstream conf_file(EPRO_TEXT("./config/configs.json"), std::ifstream::in);
+		std::ifstream conf_file(config_directory / EPRO_TEXT("configs.json"), std::ifstream::in);
+		if (!conf_file)
+			conf_file.open(sysconfig_directory / EPRO_TEXT("configs.json"));
 		if(conf_file.good()) {
 			try {
 				conf_file >> configs;
@@ -18,7 +96,7 @@ GameConfig::GameConfig() {
 				//throw(e);
 			}
 		}
-		std::ifstream user_conf_file(EPRO_TEXT("./config/user_configs.json"), std::ifstream::in);
+                std::ifstream user_conf_file(config_directory / EPRO_TEXT("user_configs.json"), std::ifstream::in);
 		if(user_conf_file.good()) {
 			try {
 				user_conf_file >> user_configs;
diff --git a/gframe/game_config.h b/gframe/game_config.h
index d38af3ed..8986b6d1 100644
--- a/gframe/game_config.h
+++ b/gframe/game_config.h
@@ -16,7 +16,13 @@ struct GameConfig
 {
 	GameConfig();
 	bool Load(const path_char* filename);
+	inline bool Load(const path_string& path) {
+		return Load(path.c_str());
+	}
 	bool Save(const path_char* filename);
+	inline bool Save(const path_string& path) {
+		return Save(path.c_str());
+	}
 
 	bool use_d3d = true;
 	bool vsync = true;
@@ -101,6 +107,13 @@ struct GameConfig
 	path_string locale = EPRO_TEXT("English");
 	path_string working_directory = EPRO_TEXT("./");
 
+	path_string cache_directory = EPRO_TEXT("./");
+	path_string config_directory = EPRO_TEXT("./config");
+	path_string data_directory = EPRO_TEXT("./");
+
+	path_string sysconfig_directory = EPRO_TEXT("./config");
+	path_string sysdata_directory = EPRO_TEXT("./");
+
 	nlohmann::json configs;
 	nlohmann::json user_configs;
 };
diff --git a/gframe/gframe.cpp b/gframe/gframe.cpp
index d574d9ce..d759576c 100644
--- a/gframe/gframe.cpp
+++ b/gframe/gframe.cpp
@@ -236,7 +236,6 @@ int main(int argc, char* argv[]) {
 		ygo::gImageDownloader = data->imageDownloader.get();
 		ygo::gDataManager = data->dataManager.get();
 		ygo::gSoundManager = data->sounds.get();
-		ygo::gGameConfig = data->configs.get();
 		ygo::gRepoManager = data->gitManager.get();
 		ygo::gdeckManager = data->deckManager.get();
 	}
diff --git a/gframe/image_downloader.cpp b/gframe/image_downloader.cpp
index 1c164ad8..1bcff817 100644
--- a/gframe/image_downloader.cpp
+++ b/gframe/image_downloader.cpp
@@ -4,6 +4,7 @@
 #include <fmt/format.h>
 #include "logging.h"
 #include "utils.h"
+#include "game_config.h"
 #ifdef __ANDROID__
 #include "Android/porting_android.h"
 #endif
@@ -88,22 +89,22 @@ void ImageDownloader::DownloadPic() {
 		downloading_images[type][file.code].status = DOWNLOADING;
 		downloading.push_back(std::move(file));
 		pic_download.unlock();
-		name = fmt::format(EPRO_TEXT("./pics/temp/{}"), code);
+		name = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/{}"), code);
 		if(type == THUMB)
 			type = ART;
 		switch(type) {
 			case ART:
 			case THUMB: {
-				dest_folder = fmt::format(EPRO_TEXT("./pics/{}"), code);
+				dest_folder = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("./pics/{}"), code);
 				break;
 			}
 			case FIELD: {
-				dest_folder = fmt::format(EPRO_TEXT("./pics/field/{}"), code);
+				dest_folder = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("./pics/field/{}"), code);
 				name.append(EPRO_TEXT("_f"));
 				break;
 			}
 			case COVER: {
-				dest_folder = fmt::format(EPRO_TEXT("./pics/cover/{}"), code);
+				dest_folder = fmt::format(gGameConfig->cache_directory / EPRO_TEXT("./pics/cover/{}"), code);
 				name.append(EPRO_TEXT("_c"));
 				break;
 			}
diff --git a/gframe/image_manager.cpp b/gframe/image_manager.cpp
index c3788612..96fe8d92 100644
--- a/gframe/image_manager.cpp
+++ b/gframe/image_manager.cpp
@@ -9,18 +9,52 @@
 #include <fstream>
 #include <curl/curl.h>
 
-#define BASE_PATH EPRO_TEXT("./textures/")
+#define BASE_PATH EPRO_TEXT("textures/")
 
 namespace ygo {
+void ImageManager::InitTexture_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, path_string path)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = driver->getTexture((textures_path / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path / jpg).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / jpg).c_str());
+	default_texture = texture;
+}
+void ImageManager::InitTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, path_string path, irr::s32 w, irr::s32 h)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = GetTextureFromFile((textures_path / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	default_texture = texture;
+}
+void ImageManager::GetTexture_(irr::video::ITexture*& texture, irr::video::ITexture* default_texture, path_string path)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = driver->getTexture((textures_path / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path / jpg).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / jpg).c_str());
+	if (!texture) texture = default_texture;
+}
+void ImageManager::GetTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture* default_texture, path_string path, irr::s32 w, irr::s32 h)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = GetTextureFromFile((textures_path / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = default_texture;
+}
 
-#define X(x) (textures_path + EPRO_TEXT(x)).c_str()
-#define GET(obj,fun1,fun2) obj=fun1; if(!obj) obj=fun2;
-#define GTFF(path,ext,w,h) GetTextureFromFile(X(path ext), mainGame->Scale(w), mainGame->Scale(h))
-#define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h)) def_##obj=obj;
-#define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg"))) def_##obj=obj;
+#define GET_TEXTURE_SIZED(obj,path,w,h) InitTextureSized_(obj,def_##obj,EPRO_TEXT(path),w,h);
+#define GET_TEXTURE(obj,path) InitTexture_(obj,def_##obj,EPRO_TEXT(path));
 bool ImageManager::Initial() {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
-	textures_path = BASE_PATH;
+	textures_path = gGameConfig->data_directory / BASE_PATH;
+	textures_path2 = gGameConfig->sysdata_directory / BASE_PATH;
 	GET_TEXTURE_SIZED(tCover[0],"cover", CARD_IMG_WIDTH, CARD_IMG_HEIGHT)
 	GET_TEXTURE_SIZED(tCover[1],"cover2", CARD_IMG_WIDTH, CARD_IMG_HEIGHT)
 	if(!tCover[1]){
@@ -77,12 +111,10 @@ bool ImageManager::Initial() {
 	return true;
 }
 
-#undef GET
 #undef GET_TEXTURE
 #undef GET_TEXTURE_SIZED
-#define GET(obj,fun1,fun2,fallback) obj=fun1; if(!obj) obj=fun2; if(!obj) obj=fallback;
-#define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h),def_##obj)
-#define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg")),def_##obj)
+#define GET_TEXTURE_SIZED(obj,path,w,h) GetTextureSized_(obj,def_##obj,EPRO_TEXT(path),w,h);
+#define GET_TEXTURE(obj,path) GetTexture_(obj,def_##obj,EPRO_TEXT(path));
 void ImageManager::ChangeTextures(const path_string & _path) {
 	if(_path == textures_path)
 		return;
@@ -131,11 +163,10 @@ void ImageManager::ChangeTextures(const path_string & _path) {
 	RefreshCovers();
 }
 void ImageManager::ResetTextures() {
-	ChangeTextures(BASE_PATH);
+	ChangeTextures(gGameConfig->data_directory / BASE_PATH);
 }
 #undef GET_TEXTURE
 #undef GET_TEXTURE_SIZED
-#undef X
 void ImageManager::SetDevice(irr::IrrlichtDevice* dev) {
 	device = dev;
 	driver = dev->getVideoDriver();
@@ -221,30 +252,13 @@ void ImageManager::ClearFutureObjects(loading_map* map1, loading_map* map2, load
 }
 void ImageManager::RefreshCovers() {
 	irr::video::ITexture* tmp_cover = nullptr;
-#undef GET
-#define GET(obj,fun1,fun2) obj=fun1; if(!obj) obj=fun2;
-#define X(x) BASE_PATH x
-#define GET_TEXTURE_SIZED(obj,path) GET(tmp_cover,GetTextureFromFile(X( path".png"),sizes[1].first,sizes[1].second),GetTextureFromFile(X( path".jpg"),sizes[1].first,sizes[1].second))\
+#define GET_TEXTURE_SIZED(obj,path) GetTextureSized_(tmp_cover,NULL,EPRO_TEXT(path),sizes[1].first,sizes[1].second); \
 										if(tmp_cover) {\
 											obj = tmp_cover;\
 										}
 	GET_TEXTURE_SIZED(tCover[0], "cover")
 	GET_TEXTURE_SIZED(tCover[1], "cover2")
-#undef X
-#define X(x) (textures_path + EPRO_TEXT(x)).c_str()
-	if(textures_path != path_string(BASE_PATH)) {
-		GET(tmp_cover, GetTextureFromFile(X("cover.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("cover.jpg"), sizes[1].first, sizes[1].second))
-		if(tmp_cover){
-			tCover[0] = tmp_cover;
-		}
-		GET(tmp_cover, GetTextureFromFile(X("cover2.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("cover2.jpg"), sizes[1].first, sizes[1].second))
-		if(tmp_cover){
-			tCover[1] = tmp_cover;
-		}
-	}
 #undef GET_TEXTURE_SIZED
-#undef GET
-#undef GTFF
 }
 void ImageManager::ClearCachedTextures(bool resize) {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
diff --git a/gframe/image_manager.h b/gframe/image_manager.h
index 2cf3d184..02349d12 100644
--- a/gframe/image_manager.h
+++ b/gframe/image_manager.h
@@ -124,11 +124,16 @@ private:
 	A(tFieldTransparent[2][4])
 	A(tSettings)
 #undef A
+	void GetTexture_(irr::video::ITexture*& texture, irr::video::ITexture* fallback, path_string path);
+	void GetTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture* fallback, path_string path, irr::s32 w, irr::s32 h);
+	void InitTexture_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, path_string path);
+	void InitTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, path_string path, irr::s32 w, irr::s32 h);
 	void ClearFutureObjects(loading_map* map1, loading_map* map2, loading_map* map3, loading_map* map4);
 	void RefreshCovers();
 	image_path LoadCardTexture(uint32_t code, imgType type, std::atomic<irr::s32>& width, std::atomic<irr::s32>& height, chrono_time timestamp_id, std::atomic<chrono_time>& source_timestamp_id);
 	loading_map* loading_pics[4];
 	path_string textures_path;
+	path_string textures_path2;
 	std::pair<std::atomic<irr::s32>, std::atomic<irr::s32>> sizes[3];
 	std::atomic<chrono_time> timestamp_id;
 	std::map<irr::io::path, irr::video::ITexture*> g_txrCache;
diff --git a/gframe/premake5.lua b/gframe/premake5.lua
index 757c0cff..c1ddd20d 100644
--- a/gframe/premake5.lua
+++ b/gframe/premake5.lua
@@ -24,6 +24,9 @@ local ygopro_config=function(static_core)
 	if _OPTIONS["environment-paths"] then
 		defines { "YGOPRO_ENVIRONMENT_PATHS" }
 	end
+	if _OPTIONS["xdg-environment"] then
+		defines { "XDG_ENVIRONMENT" }
+	end
 
 	includedirs "../ocgcore"
 	links { "clzma", "freetype", "Irrlicht" }
diff --git a/gframe/replay.cpp b/gframe/replay.cpp
index 9ef11d92..d2cec2c0 100644
--- a/gframe/replay.cpp
+++ b/gframe/replay.cpp
@@ -1,4 +1,5 @@
 #include "replay.h"
+#include "game_config.h"
 #include <algorithm>
 #include <fstream>
 #include "lzma/LzmaLib.h"
@@ -38,7 +39,7 @@ void Replay::BeginRecord(bool write, path_string name) {
 		fp.close();
 	is_recording = false;
 	if(write) {
-		fp.open(name, std::ofstream::binary);
+		fp.open(gGameConfig->data_directory / name, std::ofstream::binary);
 		if(!fp.is_open()) {
 			return;
 		}
@@ -94,7 +95,7 @@ void Replay::EndRecord(size_t size) {
 	is_recording = false;
 }
 void Replay::SaveReplay(const path_string& name) {
-	std::ofstream replay_file(fmt::format(EPRO_TEXT("./replay/{}.yrpX"), name.c_str()), std::ofstream::binary);
+	std::ofstream replay_file(fmt::format(gGameConfig->data_directory / EPRO_TEXT("replay/{}.yrpX"), name.c_str()), std::ofstream::binary);
 	if(!replay_file.is_open())
 		return;
 	replay_file.write((char*)&pheader, sizeof(pheader));
@@ -146,7 +147,7 @@ bool Replay::OpenReplay(const path_string& name) {
 	Reset();
 	std::ifstream replay_file(name, std::ifstream::binary);
 	if(!replay_file.is_open()) {
-		replay_file.open(EPRO_TEXT("./replay/") + name, std::ifstream::binary);
+		replay_file.open(gGameConfig->data_directory / EPRO_TEXT("replay/") + name, std::ifstream::binary);
 		if(!replay_file.is_open()) {
 			replay_name.clear();
 			return false;
diff --git a/gframe/single_mode.cpp b/gframe/single_mode.cpp
index e6317160..5f8243a5 100644
--- a/gframe/single_mode.cpp
+++ b/gframe/single_mode.cpp
@@ -154,7 +154,7 @@ restart:
 		if(open_file) {
 			script_name = Utils::ToUTF8IfNeeded(open_file_name);
 			if(!mainGame->LoadScript(pduel, script_name)) {
-				script_name = Utils::ToUTF8IfNeeded(EPRO_TEXT("./puzzles/") + open_file_name);
+				script_name = Utils::ToUTF8IfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles") / open_file_name);
 				if(!mainGame->LoadScript(pduel, script_name))
 					loaded = false;
 			}
diff --git a/gframe/sound_manager.cpp b/gframe/sound_manager.cpp
index 1e3d98c7..dd1380ea 100644
--- a/gframe/sound_manager.cpp
+++ b/gframe/sound_manager.cpp
@@ -40,14 +40,14 @@ bool SoundManager::IsUsable() {
 }
 void SoundManager::RefreshBGMList() {
 #ifdef BACKEND
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/duel"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/menu"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/deck"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/advantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/disadvantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/win"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/lose"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/duel"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/menu"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/deck"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/advantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/disadvantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/win"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/lose"));
 	for (auto list : BGMList) {
 		list.clear();
 	}
@@ -63,7 +63,7 @@ void SoundManager::RefreshBGMList() {
 }
 void SoundManager::RefreshBGMDir(path_string path, BGM scene) {
 #ifdef BACKEND
-	for(auto& file : Utils::FindFiles(EPRO_TEXT("./sound/BGM/") + path, { EPRO_TEXT("mp3"), EPRO_TEXT("ogg"), EPRO_TEXT("wav"), EPRO_TEXT("flac") })) {
+	for(auto& file : Utils::FindFiles(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/") + path, { EPRO_TEXT("mp3"), EPRO_TEXT("ogg"), EPRO_TEXT("wav"), EPRO_TEXT("flac") })) {
 		auto conv = Utils::ToUTF8IfNeeded(path + EPRO_TEXT("/") + file);
 		BGMList[BGM::ALL].push_back(conv);
 		BGMList[scene].push_back(conv);
diff --git a/gframe/utils.cpp b/gframe/utils.cpp
index 226ddee6..6c83578b 100644
--- a/gframe/utils.cpp
+++ b/gframe/utils.cpp
@@ -1,4 +1,5 @@
 #include "utils.h"
+#include "game_config.h"
 #include <cmath> // std::round
 #include <fstream>
 #include <sstream>
@@ -6,6 +7,8 @@
 #define WIN32_LEAN_AND_MEAN
 #include <Windows.h>
 #include <shellapi.h> // ShellExecute
+#include <shlwapi.h> // PathIsRelative{,A,W}
+#undef PathIsRelative
 #else
 #include <dirent.h>
 #include <sys/stat.h>
@@ -15,10 +18,32 @@
 #include <IFileSystem.h>
 #include "bufferio.h"
 
+#ifdef _WIN32
+namespace w32
+{
+	bool PathIsRelative(const path_char* path)
+	{
+#ifdef UNICODE
+		return PathIsRelativeW(path);
+#else
+		return PathIsRelativeA(path);
+#endif
+	}
+}
+#endif
+
 namespace ygo {
 	std::vector<Utils::SynchronizedIrrArchive> Utils::archives;
 	irr::io::IFileSystem* Utils::filesystem;
 
+	bool Utils::PathIsRelative(const path_string& path) {
+#ifdef _WIN32
+		return w32::PathIsRelative(path.c_str());
+#else
+		return path[0] != EPRO_TEXT('/');
+#endif
+	}
+
 	bool Utils::MakeDirectory(const path_string& path) {
 #ifdef _WIN32
 		return CreateDirectory(path.c_str(), NULL) || ERROR_ALREADY_EXISTS == GetLastError();
@@ -108,15 +133,19 @@ namespace ygo {
 	}
 	void Utils::CreateResourceFolders() {
 		//create directories if missing
-		MakeDirectory(EPRO_TEXT("deck"));
-		MakeDirectory(EPRO_TEXT("puzzles"));
-		MakeDirectory(EPRO_TEXT("pics"));
-		MakeDirectory(EPRO_TEXT("pics/field"));
-		MakeDirectory(EPRO_TEXT("pics/cover"));
-		MakeDirectory(EPRO_TEXT("pics/temp/"));
-		ClearDirectory(EPRO_TEXT("pics/temp/"));
-		MakeDirectory(EPRO_TEXT("replay"));
-		MakeDirectory(EPRO_TEXT("screenshots"));
+		MakeDirectory(gGameConfig->config_directory);
+		MakeDirectory(gGameConfig->data_directory);
+		MakeDirectory(gGameConfig->cache_directory);
+
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("deck"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("puzzles"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/field"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/cover"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		ClearDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("replay"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("screenshots"));
 	}
 
 	void Utils::FindFiles(const path_string& path, const std::function<void(path_string, bool, void*)>& cb, void* payload) {
@@ -146,8 +175,11 @@ namespace ygo {
 
 	void Utils::PathForeach(const path_string& path, const std::function<void(path_string)>& cb)
 	{
-		// FIXME: should be ';' in WIN32 and WIN64.
+#ifdef _WIN32
+		static const path_char path_sep = EPRO_TEXT(';');
+#else
 		static const path_char path_sep = EPRO_TEXT(':');
+#endif
 		std::basic_istringstream<path_char> dirs(path);
 		path_string dir;
 		while (std::getline(dirs, dir, path_sep))
diff --git a/gframe/utils.h b/gframe/utils.h
index 75b96a20..b5f339e8 100644
--- a/gframe/utils.h
+++ b/gframe/utils.h
@@ -63,6 +63,7 @@ namespace ygo {
 		};
 		static std::vector<SynchronizedIrrArchive> archives;
 		static irr::io::IFileSystem* filesystem;
+		static bool PathIsRelative(const path_string& path);
 		static bool MakeDirectory(const path_string& path);
 		static bool FileCopy(const path_string& source, const path_string& destination);
 		static bool FileMove(const path_string& source, const path_string& destination);
diff --git a/gframe/utils_gui.cpp b/gframe/utils_gui.cpp
index ed235d53..f1307ca7 100644
--- a/gframe/utils_gui.cpp
+++ b/gframe/utils_gui.cpp
@@ -1,4 +1,5 @@
 #include "utils_gui.h"
+#include "game_config.h"
 #include <irrlicht.h>
 #include <ICursorControl.h>
 #include <fmt/chrono.h>
@@ -111,7 +112,7 @@ bool GUIUtils::TakeScreenshot(irr::IrrlichtDevice* device)
 		return false;
 	}
 	auto now = std::time(nullptr);
-	path_string filename(fmt::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now)).c_str());
+	path_string filename(gGameConfig->data_directory / fmt::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now)).c_str());
 	if (!driver->writeImageToFile(image, filename.c_str())) {
 		device->getLogger()->log(L"Failed to take screenshot.", irr::ELL_WARNING);
 		image->drop();
diff --git a/premake5.lua b/premake5.lua
index 8d13fa47..31337be8 100644
--- a/premake5.lua
+++ b/premake5.lua
@@ -50,6 +50,11 @@ newoption {
 	trigger = "environment-paths",
 	description = "Read databases, scripts and images from YGOPRO_*_PATH"
 }
+newoption
+{
+	trigger = "xdg-environment",
+	description = "Use XDG config, data and cache directories."
+}
 workspace "ygo"
 	location "build"
 	language "C++"
-- 
2.27.0

