From 8856e3da349c495561c3f123395acaeb6b31279a Mon Sep 17 00:00:00 2001
From: LordYuuma <lordyuuma@gmail.com>
Date: Sat, 12 Jun 2021 01:20:18 +0200
Subject: [PATCH] edopro: Respect XDG paths.

* premake5.lua: (xdg-environment): New option.
* gframe/data_handler.cpp (DataHandler):
Initialize gGameConfig early.
Load strings from config_directory, falling back to sysconfig_directory.
* gframe/deck_manager.cpp (LoadLFList): Load LFLists from data_directory.
(LoadDeck, LoadDeckDouble, DeleteDeck, RenameDeck): Use data_directory.
* gframe/game.cpp (Initialize): Load skins, replays and singles from
data_directory.
(ApplySkin): Load textures from data_directory.
(RefreshDeck): Load decks from data_directory.
(SaveConfig): Save config in config_directory.
(LoadScript): Allow absolute paths.
(PopulateResourceDirectories): Use data_directory and cache_directory
for pics.
(PopulateResourceDirectories)[!YGOPRO_ENVIRONMENT_PATHS]: Use data_directory
for scripts.
(PopulateLocales): Use config_directory.
* gframe/game_config.cpp [XDG_ENVIRONMENT,_WIN32](GetSpecialFolder): New
procedure.
(GameConfig)[XDG_ENVIRONMENT]: Initialize cache_directory,
config_directory, and data_directory according to environment.
Set sane values for sysconfig_directory and sysdata_directory.
(GameConfig)[XDG_ENVIRONMENT, _WIN32]: Default cache directory to
CSIDL_INTERNET_CACHE.
Default config and data directory to CSIDL_LOCAL_APPDATA.
(GameConfig): Load conf_file from config_directory, defaulting to
sysconfig_directory.
* gframe/game_config.h (Load,Save): Add path_string& overloads.
(cache_directory,config_directory,data_directory)
(sysconfig_directory,sysdata_directory): New fields.
* gframe/gframe.cpp (main): Don't set gGameConfig, already done.
* gframe/image_downloader.cpp (DownloadPic): Use cache_directory.
* gframe/image_manager.h: (textures_path2): New field.
(InitTexture_,InitTextureSized_,GetTexture_,GetTextureSized_): New helpers.
* gframe/image_manager.cpp (Initial): Initialize textures_path with
data_directory and textures_path2 with sysdata_directory.
(InitTexture_,InitTextureSized_,GetTexture_,GetTextureSized_): Implement.
(X,GET): Removed macro.
(GET_TEXTURE_SIZED,GET_TEXTURE): Implement in terms of InitTextureSized_,
InitTexture_, GetTextureSized_ and GetTexture_.
(RefreshCovers): Refactor away some duplicate operations now that we have
textures_path2.
* gframe/premake5.lua [xdg-environment]: Define XDG_ENVIRONMENT.
* gframe/replay.cpp (BeginRecord,SaveReplay,OpenReplay): Load replays
from data_directory.
* gframe/sound_manager.cpp (RefreshBGMList,RefreshBGMDir): Properly expand
working_directory.
* gframe/utils.h (PathIsRelative): New procedure.
* gframe/utils.cpp (CreateResourceFolders): Create config_directory,
data_directory and cache_directory.
Create pics structure in cache_directory, create deck, puzzles, replay
and screenshots folder in data_directory.
(PathIsRelative): Implement it.
* gframe/utils_gui.cpp (TakeScreenshot): Save in data_directory.
---
 gframe/data_handler.cpp     |   9 +--
 gframe/deck_manager.cpp     |  20 ++++---
 gframe/deck_manager.h       |   1 +
 gframe/game.cpp             |  62 +++++++++++----------
 gframe/game_config.cpp      |  85 +++++++++++++++++++++++++++-
 gframe/game_config.h        |   7 +++
 gframe/gframe.cpp           |   1 -
 gframe/image_downloader.cpp |  34 +++++-------
 gframe/image_manager.cpp    | 107 ++++++++++++++++++------------------
 gframe/image_manager.h      |   5 ++
 gframe/premake5.lua         |   3 +
 gframe/replay.cpp           |   6 +-
 gframe/single_mode.cpp      |   2 +-
 gframe/sound_manager.cpp    |  74 +++++++++++++------------
 gframe/utils.cpp            |  45 ++++++++++++---
 gframe/utils.h              |   1 +
 gframe/utils_gui.cpp        |   4 +-
 premake5.lua                |   5 ++
 18 files changed, 301 insertions(+), 170 deletions(-)

diff --git a/gframe/data_handler.cpp b/gframe/data_handler.cpp
index 6bbafc73..2481fc8f 100644
--- a/gframe/data_handler.cpp
+++ b/gframe/data_handler.cpp
@@ -140,8 +140,9 @@ DataHandler::DataHandler() {
 #endif
 	filesystem = new irr::io::CFileSystem();
 	dataManager = std::unique_ptr<DataManager>(new DataManager());
-	auto strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./config/strings.conf"));
-	strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./expansions/strings.conf")) || strings_loaded;
+	auto strings_loaded = dataManager->LoadStrings(configs->config_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = strings_loaded || dataManager->LoadStrings(configs->sysconfig_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = dataManager->LoadStrings(configs->data_directory / EPRO_TEXT("expansions/strings.conf")) || strings_loaded;
 	if(!strings_loaded)
 		throw std::runtime_error("Failed to load strings!");
 	Utils::filesystem = filesystem;
@@ -157,8 +158,8 @@ DataHandler::DataHandler() {
 	LoadDatabases();
 	LoadPicUrls();
 	deckManager->LoadLFList();
-	dataManager->LoadIdsMapping(EPRO_TEXT("./config/mappings.json"));
-	WindBotPanel::absolute_deck_path = Utils::ToUnicodeIfNeeded(Utils::GetAbsolutePath(EPRO_TEXT("./deck")));
+	dataManager->LoadIdsMapping(configs->config_directory / EPRO_TEXT("mappings.json"));
+	WindBotPanel::absolute_deck_path = Utils::ToUnicodeIfNeeded(configs->data_directory / EPRO_TEXT("./deck"));
 }
 DataHandler::~DataHandler() {
 	if(filesystem)
diff --git a/gframe/deck_manager.cpp b/gframe/deck_manager.cpp
index 86c24ed5..cd994dc1 100644
--- a/gframe/deck_manager.cpp
+++ b/gframe/deck_manager.cpp
@@ -6,6 +6,9 @@
 #include "data_manager.h"
 #include "game.h"
 #include <IGUIEditBox.h>
+#include <iostream>
+#include <fstream>
+#include <fmt/format.h>
 #include "Base64.h"
 #include "utils.h"
 #include "client_card.h"
@@ -307,13 +310,13 @@ static bool LoadCardList(const epro::path_string& name, cardlist_type* mainlist
 		*retsidec = sidec;
 	return true;
 }
-bool DeckManager::LoadDeckFromFile(epro::path_stringview file, Deck& out, bool separated) {
+bool DeckManager::LoadDeckFromFile(epro::path_stringview name, Deck& out, bool separated) {
 	cardlist_type mainlist;
 	cardlist_type sidelist;
 	cardlist_type extralist;
-	if(!LoadCardList(fmt::format(EPRO_TEXT("./deck/{}.ydk"), file), &mainlist, separated ? &extralist : nullptr, &sidelist)) {
-		if(!LoadCardList({ file.data(), file.size() }, &mainlist, separated ? &extralist : nullptr, &sidelist))
-			return false;
+        const auto fullname = gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name);
+	if(!LoadCardList(fullname, &mainlist, separated ? &extralist : nullptr, &sidelist)) {
+		return false;
 	}
 	LoadDeck(out, mainlist, sidelist, separated ? &extralist : nullptr);
 	return true;
@@ -403,7 +406,7 @@ bool DeckManager::LoadSide(Deck& deck, uint32_t* dbuf, uint32_t mainc, uint32_t
 	return true;
 }
 bool DeckManager::SaveDeck(epro::path_stringview name, const Deck& deck) {
-	const auto fullname = fmt::format(EPRO_TEXT("./deck/{}.ydk"), name);
+	const auto fullname = gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name);
 	FileStream deckfile{ fullname, FileStream::out };
 	if(deckfile.fail())
 		return false;
@@ -419,7 +422,7 @@ bool DeckManager::SaveDeck(epro::path_stringview name, const Deck& deck) {
 	return true;
 }
 bool DeckManager::SaveDeck(epro::path_stringview name, const cardlist_type& mainlist, const cardlist_type& extralist, const cardlist_type& sidelist) {
-	const auto fullname = fmt::format(EPRO_TEXT("./deck/{}.ydk"), name);
+	const auto fullname = gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name);
 	FileStream deckfile{ fullname, FileStream::out };
 	if(deckfile.fail())
 		return false;
@@ -562,9 +565,10 @@ bool DeckManager::ImportDeckBase64Omega(Deck& deck, epro::wstringview buffer) {
 	return true;
 }
 bool DeckManager::DeleteDeck(Deck& deck, epro::path_stringview name) {
-	return Utils::FileDelete(fmt::format(EPRO_TEXT("./deck/{}.ydk"), name));
+	return Utils::FileDelete(gGameConfig->data_directory / fmt::format(EPRO_TEXT("deck/{}.ydk"), name));
 }
 bool DeckManager::RenameDeck(epro::path_stringview oldname, epro::path_stringview newname) {
-	return Utils::FileMove(fmt::format(EPRO_TEXT("./deck/{}.ydk"), oldname), fmt::format(EPRO_TEXT("./deck/{}.ydk"), newname));
+	epro::path_string deck = gGameConfig->data_directory / EPRO_TEXT("deck");
+	return Utils::FileMove(deck / oldname + EPRO_TEXT(".ydk"), deck / newname + EPRO_TEXT(".ydk"));
 }
 }
diff --git a/gframe/deck_manager.h b/gframe/deck_manager.h
index 637a7680..12906a63 100644
--- a/gframe/deck_manager.h
+++ b/gframe/deck_manager.h
@@ -8,6 +8,7 @@
 #include "text_types.h"
 #include "data_manager.h"
 #include "deck.h"
+#include "game_config.h"
 
 namespace ygo {
 
diff --git a/gframe/game.cpp b/gframe/game.cpp
index c0cf1553..6eb3566d 100644
--- a/gframe/game.cpp
+++ b/gframe/game.cpp
@@ -149,7 +149,7 @@ void Game::Initialize() {
 	if(!(ocgcore = LoadOCGcore(Utils::GetWorkingDirectory())) && !(ocgcore = LoadOCGcore(fmt::format(EPRO_TEXT("{}/expansions/"), Utils::GetWorkingDirectory()))))
 		coreloaded = false;
 #endif
-	skinSystem = new CGUISkinSystem(fmt::format(EPRO_TEXT("{}/skin"), Utils::GetWorkingDirectory()).data(), device);
+	skinSystem = new CGUISkinSystem(fmt::format(EPRO_TEXT("{}/skin"), gGameConfig->data_directory).data(), device);
 	if(!skinSystem)
 		throw std::runtime_error("Couldn't create skin system");
 	linePatternGL = 0x0f0f;
@@ -597,7 +597,7 @@ void Game::Initialize() {
 	stHandTestSettings->setEnabled(coreloaded);
 	stHandTestSettings->setTextAlignment(irr::gui::EGUIA_CENTER, irr::gui::EGUIA_CENTER);
 	defaultStrings.emplace_back(stHandTestSettings, 1375);
-	
+
 	wHandTest = env->addWindow(Scale(mainMenuLeftX, 200, mainMenuRightX, 450), false, gDataManager->GetSysString(1297).data());
 	wHandTest->getCloseButton()->setVisible(false);
 	wHandTest->setVisible(false);
@@ -748,7 +748,7 @@ void Game::Initialize() {
 	wReplay->getCloseButton()->setVisible(false);
 	wReplay->setVisible(false);
 	lstReplayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wReplay, LISTBOX_REPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
-	lstReplayList->setWorkingPath(L"./replay", true);
+	lstReplayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("replay")), true);
 	lstReplayList->addFilteredExtensions({L"yrp", L"yrpx"});
 	lstReplayList->setItemHeight(Scale(18));
 	btnLoadReplay = env->addButton(Scale(470, 355, 570, 380), wReplay, BUTTON_LOAD_REPLAY, gDataManager->GetSysString(1348).data());
@@ -788,7 +788,7 @@ void Game::Initialize() {
 	wSinglePlay->setVisible(false);
 	lstSinglePlayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wSinglePlay, LISTBOX_SINGLEPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
 	lstSinglePlayList->setItemHeight(Scale(18));
-	lstSinglePlayList->setWorkingPath(L"./puzzles", true);
+	lstSinglePlayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles")), true);
 	lstSinglePlayList->addFilteredExtensions({L"lua"});
 	btnLoadSinglePlay = env->addButton(Scale(470, 355, 570, 380), wSinglePlay, BUTTON_LOAD_SINGLEPLAY, gDataManager->GetSysString(1357).data());
 	defaultStrings.emplace_back(btnLoadSinglePlay, 1357);
@@ -1238,7 +1238,7 @@ void Game::PopulateGameHostWindows() {
 		chkNoCheckDeckSizeSecondary = env->addCheckBox(gGameConfig->noCheckDeckSize, GetNextRect(), tDeckSettings, DONT_CHECK_DECK_SIZE, gDataManager->GetSysString(12113).data());
 		defaultStrings.emplace_back(chkNoCheckDeckSizeSecondary, 12113);
 		menuHandler.MakeElementSynchronized(chkNoCheckDeckSizeSecondary);
-		
+
 #define ADD_DECK_SIZE_CHECKBOXES(deck) do { \
 		eb##deck##Min = env->addEditBox(WStr(gGameConfig->min##deck##DeckSize), GetCurrentRectWithXOffset(310, 360), true, tDeckSettings, EDITBOX_NUMERIC); \
 		defaultStrings.emplace_back(env->addStaticText(gDataManager->GetSysString(12106 + idx).data(), GetCurrentRectWithXOffset(20, 300), false, false, tDeckSettings), 12106 + idx); \
@@ -2373,7 +2373,7 @@ bool Game::ApplySkin(const epro::path_string& skinname, bool reload, bool firstr
 #include "custom_skin_enum.inl"
 #undef DECLR
 #undef CLR
-			imageManager.ChangeTextures(fmt::format(EPRO_TEXT("./skin/{}/textures/"), prev_skin));
+			imageManager.ChangeTextures(gGameConfig->data_directory / EPRO_TEXT("skin/") + prev_skin + EPRO_TEXT("/textures/"));
 		} else {
 			if(firstrun)
 				return false;
@@ -2428,7 +2428,7 @@ bool Game::ApplySkin(const epro::path_string& skinname, bool reload, bool firstr
 }
 void Game::RefreshDeck(irr::gui::IGUIComboBox* cbDeck) {
 	cbDeck->clear();
-	for(auto& file : Utils::FindFiles(EPRO_TEXT("./deck/"), { EPRO_TEXT("ydk") })) {
+	for(auto& file : Utils::FindFiles(gGameConfig->data_directory / EPRO_TEXT("deck/"), { EPRO_TEXT("ydk") })) {
 		file.erase(file.size() - 4);
 		cbDeck->addItem(Utils::ToUnicodeIfNeeded(file).data());
 	}
@@ -2576,7 +2576,7 @@ void Game::SaveConfig() {
 	gGameConfig->useIntegratedGpu = gSettings.chkIntegratedGPU->isChecked();
 #endif
 	gGameConfig->driver_type = static_cast<irr::video::E_DRIVER_TYPE>(gSettings.cbVideoDriver->getItemData(gSettings.cbVideoDriver->getSelected()));
-	gGameConfig->Save(EPRO_TEXT("./config/system.conf"));
+	gGameConfig->Save(gGameConfig->config_directory / EPRO_TEXT("system.conf"));
 }
 Game::RepoGui* Game::AddGithubRepositoryStatusWindow(const GitRepo* repo) {
 	std::wstring name = BufferIO::DecodeUTF8(repo->repo_name);
@@ -3624,7 +3624,7 @@ void Game::OnResize() {
 	repos_with_min_x(tabSettings.scrSoundVolume);
 	repos_with_min_x(tabSettings.scrMusicVolume);
 	repos_with_min_x(btnTabShowSettings);
-	
+
 	SetCentered(gSettings.window);
 
 	ResizePhaseButtons();
@@ -3773,6 +3773,8 @@ std::wstring Game::ReadPuzzleMessage(epro::wstringview script_name) {
 	return BufferIO::DecodeUTF8(res);
 }
 epro::path_string Game::FindScript(epro::path_stringview name, irr::io::IReadFile** retarchive) {
+ 	if (!Utils::PathIsRelative(name))
+		return epro::path_string(name);
 	for(auto& path : script_dirs) {
 		if(path == EPRO_TEXT("archives")) {
 			if(auto tmp = Utils::FindFileInArchives(EPRO_TEXT("script/"), name)) {
@@ -3899,32 +3901,32 @@ void Game::PopulateResourcesDirectories() {
 				cover_dirs.push_back(image_dir / EPRO_TEXT("cover/"));
 				field_dirs.push_back(image_dir / EPRO_TEXT("field/"));
 			});
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
 #else
-	script_dirs.push_back(EPRO_TEXT("./expansions/script/"));
-	auto expansions_subdirs = Utils::FindSubfolders(EPRO_TEXT("./expansions/script/"));
-	script_dirs.insert(script_dirs.end(), std::make_move_iterator(expansions_subdirs.begin()), std::make_move_iterator(expansions_subdirs.end()));
-	script_dirs.push_back(EPRO_TEXT("archives"));
-	script_dirs.push_back(EPRO_TEXT("./script/"));
-	auto script_subdirs = Utils::FindSubfolders(EPRO_TEXT("./script/"));
-	script_dirs.insert(script_dirs.end(), std::make_move_iterator(script_subdirs.begin()), std::make_move_iterator(script_subdirs.end()));
-	pic_dirs.push_back(EPRO_TEXT("./expansions/pics/"));
-	pic_dirs.push_back(EPRO_TEXT("archives"));
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./expansions/pics/cover/"));
-	cover_dirs.push_back(EPRO_TEXT("archives"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./expansions/pics/field/"));
-	field_dirs.push_back(EPRO_TEXT("archives"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	auto expansions_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	script_dirs.insert(script_dirs.end(), expansions_subdirs.begin(), expansions_subdirs.end());
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	auto script_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	script_dirs.insert(script_dirs.end(), script_subdirs.begin(), script_subdirs.end());
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/cover/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/field/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
 #endif
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/field/"));
+	pic_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/field/"));
 }
 
 void Game::PopulateLocales() {
 	locales.clear();
-	for(auto& locale : Utils::FindSubfolders(EPRO_TEXT("./config/languages/"), 1, false)) {
+	for(auto& locale : Utils::FindSubfolders(gGameConfig->config_directory / EPRO_TEXT("languages/"), 1, false)) {
 		locales.emplace_back(locale, std::vector<epro::path_string>());
 	}
 }
@@ -3941,7 +3943,7 @@ void Game::ApplyLocale(size_t index, bool forced) {
 	if(index > 0) {
 		try {
 			gGameConfig->locale = locales[index - 1].first;
-			auto locale = fmt::format(EPRO_TEXT("./config/languages/{}"), gGameConfig->locale);
+			auto locale = fmt::format(gGameConfig->config_directory / EPRO_TEXT("languages/{}"), gGameConfig->locale);
 			for(auto& file : Utils::FindFiles(locale, { EPRO_TEXT("cdb") })) {
 				gDataManager->LoadLocaleDB(fmt::format(EPRO_TEXT("{}/{}"), locale, file));
 			}
diff --git a/gframe/game_config.cpp b/gframe/game_config.cpp
index e0038f70..3b2e4c7d 100644
--- a/gframe/game_config.cpp
+++ b/gframe/game_config.cpp
@@ -6,14 +6,93 @@
 #include "config.h"
 #include "logging.h"
 #include "file_stream.h"
+#if defined(__MINGW32__) && defined(UNICODE)
+#include <fcntl.h>
+#include <ext/stdio_filebuf.h>
+#endif
+#if XDG_ENVIRONMENT && _WIN32
+#include <Shlobj.h>
+#include <Shlobj_core.h>
+
+namespace
+{
+	epro::path_string
+	GetSpecialFolder (int csidl)
+	{
+		std::vector<wchar_t> path;
+		HRESULT hr;
+		LPITEMIDLIST pidl = NULL;
+		BOOL b;
+		epro::path_string result;
+		path.reserve(MAX_PATH+1);
+
+		hr = SHGetFolderPathA (NULL, csidl, NULL, 0, path.data());
+		if (hr == S_OK)
+			return Utils::ToPathString(path.data());
+		else
+			return EPRO_TEXT("."); // default to working directory
+	}
+}
+#endif
 
 namespace ygo {
 
 GameConfig::GameConfig() {
-	Load(EPRO_TEXT("./config/system.conf"));
+#if XDG_ENVIRONMENT
+	{
+#ifndef _WIN32
+		const char* home_env = getenv("HOME");
+		epro::path_string home = Utils::ToPathString(home_env);
+#endif
+
+		const char* data_home = getenv("XDG_DATA_HOME");
+		const char* cache_home = getenv("XDG_CACHE_HOME");
+		const char* config_home = getenv("XDG_CONFIG_HOME");
+
+		if (cache_home)
+			cache_directory = Utils::ToPathString(cache_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			cache_directory = GetSpecialFolder(CSIDL_INTERNET_CACHE) / EPRO_TEXT("ygopro");
+#else
+			cache_directory = home / EPRO_TEXT(".cache/ygopro");
+#endif
+		}
+		if (data_home)
+			data_directory = Utils::ToPathString(data_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			data_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			data_directory = home / EPRO_TEXT(".local/share/ygopro");
+#endif
+		}
+
+		if (config_home)
+			config_directory = Utils::ToPathString(config_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			config_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			config_directory = home / EPRO_TEXT(".config/ygopro");
+#endif
+		}
+
+#ifdef _WIN32
+		sysconfig_directory = EPRO_TEXT("C:/ProjectIgnis");
+		sysdata_directory = EPRO_TEXT("C:/ProjectIgnis");
+#else
+		sysconfig_directory = EPRO_TEXT("/etc/ygopro");
+		sysdata_directory = EPRO_TEXT("/usr/share/ygopro");
+#endif
+	}
+#endif
+	if(!Load(config_directory / EPRO_TEXT("system.conf")))
+		Load(sysconfig_directory / EPRO_TEXT("system.conf"));
+
 	if(configs.empty()) {
 		{
-			FileStream conf_file{ EPRO_TEXT("./config/configs.json"), FileStream::in };
+			FileStream conf_file{ config_directory / EPRO_TEXT("configs.json"), FileStream::in };
 			if(!conf_file.fail()) {
 				try {
 					conf_file >> configs;
@@ -25,7 +104,7 @@ GameConfig::GameConfig() {
 			}
 		}
 		{
-			FileStream user_conf_file{ EPRO_TEXT("./config/user_configs.json"), FileStream::in };
+			FileStream user_conf_file{ config_directory / EPRO_TEXT("user_configs.json"), FileStream::in };
 			if(!user_conf_file.fail()) {
 				try {
 					user_conf_file >> user_configs;
diff --git a/gframe/game_config.h b/gframe/game_config.h
index f9a40ae6..9b46fcd5 100644
--- a/gframe/game_config.h
+++ b/gframe/game_config.h
@@ -36,6 +36,13 @@ struct GameConfig
 	std::wstring roompass; // NOT SERIALIZED
 	std::string ssl_certificate_path;
 
+	epro::path_string cache_directory = EPRO_TEXT("./");
+	epro::path_string config_directory = EPRO_TEXT("./config");
+	epro::path_string data_directory = EPRO_TEXT("./");
+
+	epro::path_string sysconfig_directory = EPRO_TEXT("./config");
+	epro::path_string sysdata_directory = EPRO_TEXT("./");
+
 	nlohmann::json configs;
 	nlohmann::json user_configs;
 };
diff --git a/gframe/gframe.cpp b/gframe/gframe.cpp
index dfee0ad0..5a2436f8 100644
--- a/gframe/gframe.cpp
+++ b/gframe/gframe.cpp
@@ -203,7 +203,6 @@ int _tmain(int argc, epro::path_char* argv[]) {
 		ygo::gImageDownloader = data->imageDownloader.get();
 		ygo::gDataManager = data->dataManager.get();
 		ygo::gSoundManager = data->sounds.get();
-		ygo::gGameConfig = data->configs.get();
 		ygo::gRepoManager = data->gitManager.get();
 		ygo::gdeckManager = data->deckManager.get();
 	}
diff --git a/gframe/image_downloader.cpp b/gframe/image_downloader.cpp
index 33b69885..871e9f7a 100644
--- a/gframe/image_downloader.cpp
+++ b/gframe/image_downloader.cpp
@@ -121,28 +121,24 @@ void ImageDownloader::DownloadPic() {
 		auto& map_elem = downloading_images[type][code];
 		map_elem.status = downloadStatus::DOWNLOADING;
 		lck.unlock();
-		auto name = fmt::format(EPRO_TEXT("./pics/temp/{}"), code);
+		auto name = gGameConfig->cache_directory / fmt::format(EPRO_TEXT("pics/temp/{}"), code);
 		if(type == imgType::THUMB)
 			type = imgType::ART;
-		epro::path_stringview dest;
-		switch(type) {
-			case imgType::ART:
-			case imgType::THUMB: {
-				dest = EPRO_TEXT("./pics/{}"_sv);
-				break;
-			}
-			case imgType::FIELD: {
-				dest = EPRO_TEXT("./pics/field/{}"_sv);
-				name.append(EPRO_TEXT("_f"));
-				break;
+		auto dest_folder = [type, &name, code]()->epro::path_string {
+			const epro::path_string code_s = fmt::format(EPRO_TEXT("{}"), code);
+			switch(type) {
+				default:
+				case imgType::ART:
+				case imgType::THUMB:
+					return gGameConfig->cache_directory / EPRO_TEXT("pics") / code_s;
+				case imgType::FIELD:
+					name.append(EPRO_TEXT("_f"));
+					return gGameConfig->cache_directory / EPRO_TEXT("pics/field") / code_s;
+				case imgType::COVER:
+					name.append(EPRO_TEXT("_c"));
+					return gGameConfig->cache_directory / EPRO_TEXT("pics/cover") / code_s;
 			}
-			case imgType::COVER: {
-				dest = EPRO_TEXT("./pics/cover/{}"_sv);
-				name.append(EPRO_TEXT("_c"));
-				break;
-			}
-		}
-		auto dest_folder = fmt::format(epro::to_fmtstring_view(dest), code);
+		}();
 		CURLcode res{ static_cast<CURLcode>(1) };
 		for(auto& src : pic_urls) {
 			if(src.type != type)
diff --git a/gframe/image_manager.cpp b/gframe/image_manager.cpp
index b3460ca8..94673ebe 100644
--- a/gframe/image_manager.cpp
+++ b/gframe/image_manager.cpp
@@ -12,15 +12,49 @@
 #include "image_downloader.h"
 #include "game.h"
 
-#define BASE_PATH EPRO_TEXT("./textures/")
+#define BASE_PATH EPRO_TEXT("textures/")
 
 namespace ygo {
+void ImageManager::InitTexture_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = driver->getTexture((textures_path / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path / jpg).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / jpg).c_str());
+	default_texture = texture;
+}
+void ImageManager::InitTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path, uint32_t w, uint32_t h)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = GetTextureFromFile((textures_path / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	default_texture = texture;
+}
+void ImageManager::GetTexture_(irr::video::ITexture*& texture, irr::video::ITexture* default_texture, epro::path_string path)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = driver->getTexture((textures_path / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path / jpg).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / png).c_str());
+	if (!texture) texture = driver->getTexture((textures_path2 / jpg).c_str());
+	if (!texture) texture = default_texture;
+}
+void ImageManager::GetTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture* default_texture, epro::path_string path, uint32_t w, uint32_t h)
+{
+	auto png = path + EPRO_TEXT(".png"), jpg = path + EPRO_TEXT(".jpg");
+	texture = GetTextureFromFile((textures_path / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / png).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = GetTextureFromFile((textures_path2 / jpg).c_str(), mainGame->Scale(w), mainGame->Scale(h));
+	if (!texture) texture = default_texture;
+}
+
 
-#define X(x) (textures_path + EPRO_TEXT(x)).data()
-#define GET(obj,fun1,fun2) do {obj=fun1; if(!obj) obj=fun2; def_##obj=obj;}while(0)
-#define GTFF(path,ext,w,h) GetTextureFromFile(X(path ext), mainGame->Scale(w), mainGame->Scale(h))
-#define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h))
-#define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg")))
+#define GET_TEXTURE_SIZED(obj,path,w,h) InitTextureSized_(obj,def_##obj,EPRO_TEXT(path),w,h)
+#define GET_TEXTURE(obj,path) InitTexture_(obj,def_##obj,EPRO_TEXT(path))
 #define CHECK_RETURN(what, name) do { if(!what) { throw std::runtime_error("Couldn't load texture: " name); }} while(0)
 ImageManager::ImageManager() {
 	stop_threads = false;
@@ -51,7 +85,8 @@ ImageManager::~ImageManager() {
 }
 bool ImageManager::Initial() {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
-	textures_path = BASE_PATH;
+	textures_path = gGameConfig->data_directory / BASE_PATH;
+	textures_path2 = gGameConfig->sysdata_directory / BASE_PATH;
 	GET_TEXTURE_SIZED(tCover[0], "cover", CARD_IMG_WIDTH, CARD_IMG_HEIGHT);
 	CHECK_RETURN(tCover[0], "cover");
 	GET_TEXTURE_SIZED(tCover[1], "cover2", CARD_IMG_WIDTH, CARD_IMG_HEIGHT);
@@ -152,21 +187,10 @@ bool ImageManager::Initial() {
 	return true;
 }
 
-#undef GET
 #undef GET_TEXTURE
 #undef GET_TEXTURE_SIZED
-#define GET(to_set,fun1,fun2,fallback) do  {\
-	irr::video::ITexture* tmp = fun1;\
-	if(!tmp)\
-		tmp = fun2;\
-	if(!tmp)\
-		tmp = fallback;\
-	if(to_set != fallback)\
-		driver->removeTexture(to_set);\
-	to_set = tmp;\
-} while(0)
-#define GET_TEXTURE_SIZED(obj,path,w,h) GET(obj,GTFF(path,".png",w,h),GTFF(path,".jpg",w,h),def_##obj)
-#define GET_TEXTURE(obj,path) GET(obj,driver->getTexture(X(path ".png")),driver->getTexture(X(path ".jpg")),def_##obj)
+#define GET_TEXTURE_SIZED(obj,path,w,h) GetTextureSized_(obj,def_##obj,EPRO_TEXT(path),w,h)
+#define GET_TEXTURE(obj,path) GetTexture_(obj,def_##obj,EPRO_TEXT(path))
 void ImageManager::ChangeTextures(epro::path_stringview _path) {
 	if(_path == textures_path)
 		return;
@@ -218,7 +242,7 @@ void ImageManager::ChangeTextures(epro::path_stringview _path) {
 	RefreshCovers();
 }
 void ImageManager::ResetTextures() {
-	ChangeTextures(BASE_PATH);
+	ChangeTextures(gGameConfig->data_directory / BASE_PATH);
 }
 void ImageManager::SetDevice(irr::IrrlichtDevice* dev) {
 	device = dev;
@@ -255,7 +279,6 @@ void ImageManager::ClearTexture(bool resize) {
 }
 #undef GET_TEXTURE
 #undef GET_TEXTURE_SIZED
-#undef X
 void ImageManager::RefreshCachedTextures() {
 	auto LoadTexture = [this](int index, texture_map& dest, auto& size, imgType type) {
 		auto& src = loaded_pics[index];
@@ -317,44 +340,18 @@ void ImageManager::ClearFutureObjects() {
 }
 void ImageManager::RefreshCovers() {
 	irr::video::ITexture* tmp_cover = nullptr;
-#undef GET
-#define GET(obj,fun1,fun2) do {obj=fun1; if(!obj) obj=fun2;} while(0)
-#define X(x) BASE_PATH x
-#define GET_TEXTURE_SIZED(obj,path) do {GET(tmp_cover,GetTextureFromFile(X( path".png"),sizes[1].first,sizes[1].second),GetTextureFromFile(X( path".jpg"),sizes[1].first,sizes[1].second));\
-										if(tmp_cover) {\
-											driver->removeTexture(obj); \
-											obj = tmp_cover;\
-										}} while(0)
+#define GET_TEXTURE_SIZED(obj,path) do {                                \
+		GetTextureSized_(tmp_cover, nullptr, EPRO_TEXT(path),	\
+				 sizes[1].first,sizes[1].second);	\
+		if(tmp_cover) {						\
+			driver->removeTexture(obj);			\
+			obj = tmp_cover;				\
+		}} while (0)
 	GET_TEXTURE_SIZED(tCover[0], "cover");
 	tCover[1] = nullptr;
 	GET_TEXTURE_SIZED(tCover[1], "cover2");
-	if(!tCover[1]) {
-		tCover[1] = tCover[0];
-		def_tCover[1] = tCover[1];
-	}
 	GET_TEXTURE_SIZED(tUnknown, "unknown");
-#undef X
-#define X(x) (textures_path + EPRO_TEXT(x)).data()
-	if(textures_path != BASE_PATH) {
-		GET(tmp_cover, GetTextureFromFile(X("cover.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("cover.jpg"), sizes[1].first, sizes[1].second));
-		if(tmp_cover){
-			driver->removeTexture(tCover[0]);
-			tCover[0] = tmp_cover;
-		}
-		GET(tmp_cover, GetTextureFromFile(X("cover2.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("cover2.jpg"), sizes[1].first, sizes[1].second));
-		if(tmp_cover){
-			driver->removeTexture(tCover[1]);
-			tCover[1] = tmp_cover;
-		}
-		GET(tmp_cover, GetTextureFromFile(X("unknown.png"), sizes[1].first, sizes[1].second), GetTextureFromFile(X("unknown.jpg"), sizes[1].first, sizes[1].second));
-		if(tmp_cover){
-			driver->removeTexture(tUnknown);
-			tUnknown = tmp_cover;
-		}
-	}
 #undef GET_TEXTURE_SIZED
-#undef GET
-#undef GTFF
 }
 void ImageManager::LoadPic() {
 	Utils::SetThreadName("PicLoader");
diff --git a/gframe/image_manager.h b/gframe/image_manager.h
index e9ff8492..7e3ee3eb 100644
--- a/gframe/image_manager.h
+++ b/gframe/image_manager.h
@@ -138,11 +138,16 @@ public:
 	A(tCheckBox[3])
 #undef A
 private:
+	void GetTexture_(irr::video::ITexture*& texture, irr::video::ITexture* fallback, epro::path_string path);
+	void GetTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture* fallback, epro::path_string path, uint32_t w, uint32_t h);
+	void InitTexture_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path);
+	void InitTextureSized_(irr::video::ITexture*& texture, irr::video::ITexture*& default_texture, epro::path_string path, uint32_t w, uint32_t h);
 	void ClearFutureObjects();
 	void RefreshCovers();
 	void LoadPic();
 	load_return LoadCardTexture(uint32_t code, imgType type, const std::atomic<irr::s32>& width, const std::atomic<irr::s32>& height, chrono_time timestamp_id, const std::atomic<chrono_time>& source_timestamp_id);
 	epro::path_string textures_path;
+	epro::path_string textures_path2;
 	std::pair<std::atomic<irr::s32>, std::atomic<irr::s32>> sizes[3];
 	std::atomic<chrono_time> timestamp_id;
 	std::map<epro::path_string, irr::video::ITexture*> g_txrCache;
diff --git a/gframe/premake5.lua b/gframe/premake5.lua
index a6923154..9e0b65a9 100644
--- a/gframe/premake5.lua
+++ b/gframe/premake5.lua
@@ -51,6 +51,9 @@ local ygopro_config=function(static_core)
 	if _OPTIONS["environment-paths"] then
 		defines { "YGOPRO_ENVIRONMENT_PATHS" }
 	end
+	if _OPTIONS["xdg-environment"] then
+		defines { "XDG_ENVIRONMENT" }
+	end
 
 	includedirs "../ocgcore"
 	links { "clzma", "Irrlicht" }
diff --git a/gframe/replay.cpp b/gframe/replay.cpp
index 580c628d..f4217608 100644
--- a/gframe/replay.cpp
+++ b/gframe/replay.cpp
@@ -3,6 +3,7 @@
 #include <fmt/format.h>
 #include "lzma/LzmaLib.h"
 #include "common.h"
+#include "game_config.h"
 #include "utils.h"
 #include "file_stream.h"
 
@@ -77,7 +78,8 @@ void Replay::EndRecord(size_t size) {
 	is_recording = false;
 }
 void Replay::SaveReplay(const epro::path_string& name) {
-	auto replay_file = fileopen(fmt::format(EPRO_TEXT("./replay/{}.yrpX"), name).data(), "wb");
+	const auto replay_fname = gGameConfig->data_directory / fmt::format(EPRO_TEXT("replay/{}.yrpX"), name);
+	auto replay_file = fileopen(replay_fname.data(), "wb");
 	if(replay_file == nullptr)
 		return;
 	auto header_len = (pheader.base.flag & REPLAY_EXTENDED_HEADER) ? sizeof(ExtendedReplayHeader) : sizeof(ReplayHeader);
@@ -133,7 +135,7 @@ bool Replay::OpenReplay(const epro::path_string& name) {
 	std::vector<uint8_t> contents;
 	FileStream replay_file{ name, FileStream::in | FileStream::binary };
 	if(replay_file.fail()) {
-		FileStream replay_file2{ EPRO_TEXT("./replay/") + name, FileStream::in | FileStream::binary };
+		FileStream replay_file2{gGameConfig->data_directory /  EPRO_TEXT("replay/") + name, FileStream::in | FileStream::binary };
 		if(replay_file2.fail()) {
 			replay_name.clear();
 			return false;
diff --git a/gframe/single_mode.cpp b/gframe/single_mode.cpp
index 5b681799..13463ba3 100644
--- a/gframe/single_mode.cpp
+++ b/gframe/single_mode.cpp
@@ -155,7 +155,7 @@ restart:
 		if(open_file) {
 			script_name = Utils::ToUTF8IfNeeded(open_file_name);
 			if(!mainGame->LoadScript(pduel, script_name)) {
-				script_name = fmt::format("./puzzles/{}" ,script_name);
+				script_name = Utils::ToUTF8IfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles") / open_file_name);
 				loaded = mainGame->LoadScript(pduel, script_name);
 			}
 		} else {
diff --git a/gframe/sound_manager.cpp b/gframe/sound_manager.cpp
index 2a61fcb1..1ea24a6c 100644
--- a/gframe/sound_manager.cpp
+++ b/gframe/sound_manager.cpp
@@ -12,12 +12,13 @@
 #include "sound_sfml.h"
 #define BACKEND SoundSFML
 #endif
+#include "game_config.h"
 
 namespace ygo {
 SoundManager::SoundManager(double sounds_volume, double music_volume, bool sounds_enabled, bool music_enabled) {
 #ifdef BACKEND
 	fmt::print("Using: " STR(BACKEND)" for audio playback.\n");
-	working_dir = Utils::ToUTF8IfNeeded(Utils::GetWorkingDirectory());
+	working_dir = Utils::ToUTF8IfNeeded(gGameConfig->data_directory);
 	soundsEnabled = sounds_enabled;
 	musicEnabled = music_enabled;
 	try {
@@ -53,15 +54,15 @@ bool SoundManager::IsUsable() {
 }
 void SoundManager::RefreshBGMList() {
 #ifdef BACKEND
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/duel"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/menu"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/deck"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/advantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/disadvantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/win"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/lose"));
-	for (auto& list : BGMList)
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/duel"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/menu"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/deck"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/advantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/disadvantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/win"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/lose"));
+	for (auto list : BGMList)
 		list.clear();
 	RefreshBGMDir(EPRO_TEXT(""), BGM::DUEL);
 	RefreshBGMDir(EPRO_TEXT("duel"), BGM::DUEL);
@@ -76,35 +77,36 @@ void SoundManager::RefreshBGMList() {
 void SoundManager::RefreshSoundsList() {
 #ifdef BACKEND
 	static constexpr std::pair<SFX, epro::path_stringview> fx[]{
-		{SUMMON, EPRO_TEXT("./sound/summon.{}"_sv)},
-		{SPECIAL_SUMMON, EPRO_TEXT("./sound/specialsummon.{}"_sv)},
-		{ACTIVATE, EPRO_TEXT("./sound/activate.{}"_sv)},
-		{SET, EPRO_TEXT("./sound/set.{}"_sv)},
-		{FLIP, EPRO_TEXT("./sound/flip.{}"_sv)},
-		{REVEAL, EPRO_TEXT("./sound/reveal.{}"_sv)},
-		{EQUIP, EPRO_TEXT("./sound/equip.{}"_sv)},
-		{DESTROYED, EPRO_TEXT("./sound/destroyed.{}"_sv)},
-		{BANISHED, EPRO_TEXT("./sound/banished.{}"_sv)},
-		{TOKEN, EPRO_TEXT("./sound/token.{}"_sv)},
-		{ATTACK, EPRO_TEXT("./sound/attack.{}"_sv)},
-		{DIRECT_ATTACK, EPRO_TEXT("./sound/directattack.{}"_sv)},
-		{DRAW, EPRO_TEXT("./sound/draw.{}"_sv)},
-		{SHUFFLE, EPRO_TEXT("./sound/shuffle.{}"_sv)},
-		{DAMAGE, EPRO_TEXT("./sound/damage.{}"_sv)},
-		{RECOVER, EPRO_TEXT("./sound/gainlp.{}"_sv)},
-		{COUNTER_ADD, EPRO_TEXT("./sound/addcounter.{}"_sv)},
-		{COUNTER_REMOVE, EPRO_TEXT("./sound/removecounter.{}"_sv)},
-		{COIN, EPRO_TEXT("./sound/coinflip.{}"_sv)},
-		{DICE, EPRO_TEXT("./sound/diceroll.{}"_sv)},
-		{NEXT_TURN, EPRO_TEXT("./sound/nextturn.{}"_sv)},
-		{PHASE, EPRO_TEXT("./sound/phase.{}"_sv)},
-		{PLAYER_ENTER, EPRO_TEXT("./sound/playerenter.{}"_sv)},
-		{CHAT, EPRO_TEXT("./sound/chatmessage.{}"_sv)}
+		{SUMMON, EPRO_TEXT("sound/summon.{}"_sv)},
+		{SPECIAL_SUMMON, EPRO_TEXT("sound/specialsummon.{}"_sv)},
+		{ACTIVATE, EPRO_TEXT("sound/activate.{}"_sv)},
+		{SET, EPRO_TEXT("sound/set.{}"_sv)},
+		{FLIP, EPRO_TEXT("sound/flip.{}"_sv)},
+		{REVEAL, EPRO_TEXT("sound/reveal.{}"_sv)},
+		{EQUIP, EPRO_TEXT("sound/equip.{}"_sv)},
+		{DESTROYED, EPRO_TEXT("sound/destroyed.{}"_sv)},
+		{BANISHED, EPRO_TEXT("sound/banished.{}"_sv)},
+		{TOKEN, EPRO_TEXT("sound/token.{}"_sv)},
+		{ATTACK, EPRO_TEXT("sound/attack.{}"_sv)},
+		{DIRECT_ATTACK, EPRO_TEXT("sound/directattack.{}"_sv)},
+		{DRAW, EPRO_TEXT("sound/draw.{}"_sv)},
+		{SHUFFLE, EPRO_TEXT("sound/shuffle.{}"_sv)},
+		{DAMAGE, EPRO_TEXT("sound/damage.{}"_sv)},
+		{RECOVER, EPRO_TEXT("sound/gainlp.{}"_sv)},
+		{COUNTER_ADD, EPRO_TEXT("sound/addcounter.{}"_sv)},
+		{COUNTER_REMOVE, EPRO_TEXT("sound/removecounter.{}"_sv)},
+		{COIN, EPRO_TEXT("sound/coinflip.{}"_sv)},
+		{DICE, EPRO_TEXT("sound/diceroll.{}"_sv)},
+		{NEXT_TURN, EPRO_TEXT("sound/nextturn.{}"_sv)},
+		{PHASE, EPRO_TEXT("sound/phase.{}"_sv)},
+		{PLAYER_ENTER, EPRO_TEXT("sound/playerenter.{}"_sv)},
+		{CHAT, EPRO_TEXT("sound/chatmessage.{}"_sv)}
 	};
 	const auto extensions = mixer->GetSupportedSoundExtensions();
 	for(const auto& sound : fx) {
 		for(const auto& ext : extensions) {
-			const auto filename = fmt::format(epro::to_fmtstring_view(sound.second), ext);
+			const auto filename0 = fmt::format(epro::to_fmtstring_view(sound.second), ext);
+			const auto filename = Utils::ToPathString(working_dir) / filename0;
 			if(Utils::FileExists(filename)) {
 				SFXList[sound.first] = Utils::ToUTF8IfNeeded(filename);
 				break;
@@ -115,7 +117,7 @@ void SoundManager::RefreshSoundsList() {
 }
 void SoundManager::RefreshBGMDir(epro::path_stringview path, BGM scene) {
 #ifdef BACKEND
-	for(auto& file : Utils::FindFiles(fmt::format(EPRO_TEXT("./sound/BGM/{}"), path), mixer->GetSupportedMusicExtensions())) {
+	for(auto& file : Utils::FindFiles(Utils::ToPathString(working_dir) / fmt::format(EPRO_TEXT("sound/BGM/{}"), path), mixer->GetSupportedMusicExtensions())) {
 		auto conv = Utils::ToUTF8IfNeeded(fmt::format(EPRO_TEXT("{}/{}"), path, file));
 		BGMList[BGM::ALL].push_back(conv);
 		BGMList[scene].push_back(std::move(conv));
diff --git a/gframe/utils.cpp b/gframe/utils.cpp
index 8c5cfc62..3faceade 100644
--- a/gframe/utils.cpp
+++ b/gframe/utils.cpp
@@ -1,4 +1,5 @@
 #include "utils.h"
+#include "game_config.h"
 #include <cmath> // std::round
 #include <fstream>
 #include "config.h"
@@ -6,6 +7,8 @@
 #define WIN32_LEAN_AND_MEAN
 #include <Windows.h>
 #include <shellapi.h> // ShellExecute
+#include <shlwapi.h> // PathIsRelative{,A,W}
+#undef PathIsRelative
 #else
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
@@ -33,6 +36,8 @@ using Stat = struct stat;
 #endif //_WIN32
 #include <IFileArchive.h>
 #include <IFileSystem.h>
+#include <iostream>
+#include <sstream>
 #include <fmt/format.h>
 #include <IOSOperator.h>
 #include "bufferio.h"
@@ -66,6 +71,16 @@ inline void NameThreadMsvc(const char* threadName) {
 	__try {	RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info); }
 	__except(EXCEPTION_EXECUTE_HANDLER) {}
 }
+
+bool PathIsRelative(const epro::path_char* path)
+{
+#ifdef UNICODE
+	return PathIsRelativeW(path);
+#else
+	return PathIsRelativeA(path);
+#endif
+}
+}
 #pragma warning(pop)
 #endif
 const auto PSetThreadDescription = [] {
@@ -144,6 +159,14 @@ namespace ygo {
 		return false;
 	}
 
+	bool Utils::PathIsRelative(epro::path_stringview path) {
+#ifdef _WIN32
+		return PathIsRelativeW(ToUnicodeIfNeeded(path).data());
+#else
+		return path[0] != EPRO_TEXT('/');
+#endif
+	}
+
 	bool Utils::MakeDirectory(epro::path_stringview path) {
 #ifdef _WIN32
 		return SetLastErrorStringIfFailed(CreateDirectory(path.data(), nullptr) || ERROR_ALREADY_EXISTS == GetLastError());
@@ -301,15 +324,19 @@ namespace ygo {
 
 	void Utils::CreateResourceFolders() {
 		//create directories if missing
-		MakeDirectory(EPRO_TEXT("deck"));
-		MakeDirectory(EPRO_TEXT("puzzles"));
-		MakeDirectory(EPRO_TEXT("pics"));
-		MakeDirectory(EPRO_TEXT("pics/field"));
-		MakeDirectory(EPRO_TEXT("pics/cover"));
-		MakeDirectory(EPRO_TEXT("pics/temp/"));
-		ClearDirectory(EPRO_TEXT("pics/temp/"));
-		MakeDirectory(EPRO_TEXT("replay"));
-		MakeDirectory(EPRO_TEXT("screenshots"));
+		MakeDirectory(gGameConfig->config_directory);
+		MakeDirectory(gGameConfig->data_directory);
+		MakeDirectory(gGameConfig->cache_directory);
+
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("deck"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("puzzles"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/field"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/cover"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		ClearDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("replay"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("screenshots"));
 	}
 
 	std::vector<epro::path_string> Utils::FindFiles(epro::path_stringview path, const std::vector<epro::path_stringview>& extensions, int subdirectorylayers) {
diff --git a/gframe/utils.h b/gframe/utils.h
index 221fa77d..d165cf67 100644
--- a/gframe/utils.h
+++ b/gframe/utils.h
@@ -56,6 +56,7 @@ namespace ygo {
 		static irr::io::IFileSystem* filesystem;
 		static irr::IOSOperator* OSOperator;
 		static epro::stringview GetLastErrorString();
+		static bool PathIsRelative(epro::path_stringview path);
 		static bool MakeDirectory(epro::path_stringview path);
 		static bool FileCopyFD(int source, int destination);
 		static bool FileCopy(epro::path_stringview source, epro::path_stringview destination);
diff --git a/gframe/utils_gui.cpp b/gframe/utils_gui.cpp
index c1d1ba57..778fa149 100644
--- a/gframe/utils_gui.cpp
+++ b/gframe/utils_gui.cpp
@@ -188,7 +188,7 @@ bool GUIUtils::TakeScreenshot(irr::IrrlichtDevice* device) {
 	if(!image)
 		return false;
 	const auto now = std::time(nullptr);
-	const auto filename = fmt::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now));
+	const auto filename = gGameConfig->data_directory / fmt::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now));
 	auto written = driver->writeImageToFile(image, { filename.data(), static_cast<irr::u32>(filename.size()) });
 	if(!written)
 		device->getLogger()->log(L"Failed to take screenshot.", irr::ELL_WARNING);
@@ -339,7 +339,7 @@ void GUIUtils::ShowErrorWindow(epro::stringview context, epro::stringview messag
 		nullptr, //icon url, use default, you can change it depending message_type flags
 		nullptr, //not used
 		nullptr, //localization of strings
-		header_ref, //header text 
+		header_ref, //header text
 		message_ref, //message text
 		nullptr, //default "ok" text in button
 		nullptr, //alternate button title
diff --git a/premake5.lua b/premake5.lua
index e7da2911..52b69994 100644
--- a/premake5.lua
+++ b/premake5.lua
@@ -64,6 +64,11 @@ newoption {
 	trigger = "environment-paths",
 	description = "Read databases, scripts and images from YGOPRO_*_PATH"
 }
+newoption
+{
+	trigger = "xdg-environment",
+	description = "Use XDG config, data and cache directories."
+}
 newoption {
 	trigger = "no-core",
 	description = "Ignore the ocgcore subproject and only generate the solution for yroprodll"
-- 
2.38.0

