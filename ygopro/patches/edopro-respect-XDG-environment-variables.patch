From a17b4bd7a88049efc82a7e911cd22a66ea0ecd42 Mon Sep 17 00:00:00 2001
From: LordYuuma <lordyuuma@gmail.com>
Date: Sat, 12 Jun 2021 01:20:18 +0200
Subject: [PATCH] edopro: Respect XDG paths.

* premake5.lua: (xdg-environment): New option.
* gframe/data_handler.cpp (DataHandler):
Initialize gGameConfig early.
Load strings from config_directory, falling back to sysconfig_directory.
* gframe/deck_manager.cpp (LoadLFList): Load LFLists from data_directory.
(LoadDeck, LoadDeckDouble, DeleteDeck, RenameDeck): Use data_directory.
* gframe/game.cpp (Initialize): Load skins, replays and singles from
data_directory.
(ApplySkin): Load textures from data_directory.
(RefreshDeck): Load decks from data_directory.
(SaveConfig): Save config in config_directory.
(LoadScript): Allow absolute paths.
(PopulateResourceDirectories): Use data_directory and cache_directory
for pics.
(PopulateResourceDirectories)[!YGOPRO_ENVIRONMENT_PATHS]: Use data_directory
for scripts.
(PopulateLocales): Use config_directory.
* gframe/game_config.cpp [XDG_ENVIRONMENT,_WIN32](GetSpecialFolder): New
procedure.
(GameConfig)[XDG_ENVIRONMENT]: Initialize cache_directory,
config_directory, and data_directory according to environment.
Set sane values for sysconfig_directory and sysdata_directory.
(GameConfig)[XDG_ENVIRONMENT, _WIN32]: Default cache directory to
CSIDL_INTERNET_CACHE.
Default config and data directory to CSIDL_LOCAL_APPDATA.
(GameConfig): Load conf_file from config_directory, defaulting to
sysconfig_directory.
* gframe/game_config.h (Load,Save): Add path_string& overloads.
(cache_directory,config_directory,data_directory)
(sysconfig_directory,sysdata_directory): New fields.
* gframe/gframe.cpp (main): Don't set gGameConfig, already done.
* gframe/image_downloader.cpp (DownloadPic): Use cache_directory.
* gframe/image_manager.h: (textures_path2): New field.
* gframe/image_manager.cpp (Initial): Initialize textures_path with
data_directory and textures_path2 with sysdata_directory.
(loadTextureFixedSize, loadTextureFixedSize): Use textures_path2.
(RefreshCovers): Adjust accordingly.
* gframe/premake5.lua [xdg-environment]: Define XDG_ENVIRONMENT.
* gframe/replay.cpp (BeginRecord,SaveReplay,OpenReplay): Load replays
from data_directory.
* gframe/sound_manager.cpp (RefreshBGMList,RefreshBGMDir): Properly expand
working_directory.
* gframe/utils.h (PathIsRelative): New procedure.
* gframe/utils.cpp (CreateResourceFolders): Create config_directory,
data_directory and cache_directory.
Create pics structure in cache_directory, create deck, puzzles, replay
and screenshots folder in data_directory.
(PathIsRelative): Implement it.
* gframe/utils_gui.cpp (TakeScreenshot): Save in data_directory.
---
 gframe/data_handler.cpp     |  9 ++--
 gframe/deck_manager.cpp     | 20 +++++----
 gframe/deck_manager.h       |  1 +
 gframe/game.cpp             | 56 ++++++++++++------------
 gframe/game_config.cpp      | 85 +++++++++++++++++++++++++++++++++++--
 gframe/game_config.h        |  7 +++
 gframe/image_downloader.cpp | 34 +++++++--------
 gframe/image_manager.cpp    | 27 +++++++-----
 gframe/image_manager.h      |  1 +
 gframe/premake5.lua         |  3 ++
 gframe/replay.cpp           |  5 ++-
 gframe/single_mode.cpp      |  2 +-
 gframe/sound_manager.cpp    | 73 +++++++++++++++----------------
 gframe/utils.cpp            | 45 ++++++++++++++++----
 gframe/utils.h              |  1 +
 gframe/utils_gui.cpp        |  4 +-
 premake5.lua                |  5 +++
 17 files changed, 256 insertions(+), 122 deletions(-)

diff --git a/gframe/data_handler.cpp b/gframe/data_handler.cpp
index 6a6900dc..f517c80e 100644
--- a/gframe/data_handler.cpp
+++ b/gframe/data_handler.cpp
@@ -140,8 +140,9 @@ DataHandler::DataHandler() {
 #endif
 	filesystem = new irr::io::CFileSystem();
 	dataManager = std::unique_ptr<DataManager>(new DataManager());
-	auto strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./config/strings.conf"));
-	strings_loaded = dataManager->LoadStrings(EPRO_TEXT("./expansions/strings.conf")) || strings_loaded;
+	auto strings_loaded = dataManager->LoadStrings(configs->config_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = strings_loaded || dataManager->LoadStrings(configs->sysconfig_directory / EPRO_TEXT("strings.conf"));
+	strings_loaded = dataManager->LoadStrings(configs->data_directory / EPRO_TEXT("expansions/strings.conf")) || strings_loaded;
 	if(!strings_loaded)
 		throw std::runtime_error("Failed to load strings!");
 	Utils::filesystem = filesystem;
@@ -152,8 +153,8 @@ DataHandler::DataHandler() {
 	LoadDatabases();
 	LoadPicUrls();
 	deckManager->LoadLFList();
-	dataManager->LoadIdsMapping(EPRO_TEXT("./config/mappings.json"));
-	WindBotPanel::absolute_deck_path = Utils::ToUnicodeIfNeeded(Utils::GetAbsolutePath(EPRO_TEXT("./deck")));
+	dataManager->LoadIdsMapping(configs->config_directory / EPRO_TEXT("mappings.json"));
+	WindBotPanel::absolute_deck_path = Utils::ToUnicodeIfNeeded(configs->data_directory / EPRO_TEXT("./deck"));
 }
 DataHandler::~DataHandler() {
 	if(filesystem)
diff --git a/gframe/deck_manager.cpp b/gframe/deck_manager.cpp
index f88e950e..c2803c57 100644
--- a/gframe/deck_manager.cpp
+++ b/gframe/deck_manager.cpp
@@ -6,6 +6,9 @@
 #include "data_manager.h"
 #include "game.h"
 #include <IGUIEditBox.h>
+#include <iostream>
+#include <fstream>
+#include <fmt/format.h>
 #include "Base64.h"
 #include "utils.h"
 #include "client_card.h"
@@ -311,13 +314,13 @@ static bool LoadCardList(const epro::path_string& name, cardlist_type* mainlist
 		*retsidec = sidec;
 	return true;
 }
-bool DeckManager::LoadDeckFromFile(epro::path_stringview file, Deck& out, bool separated) {
+bool DeckManager::LoadDeckFromFile(epro::path_stringview name, Deck& out, bool separated) {
 	cardlist_type mainlist;
 	cardlist_type sidelist;
 	cardlist_type extralist;
-	if(!LoadCardList(epro::format(EPRO_TEXT("./deck/{}.ydk"), file), &mainlist, separated ? &extralist : nullptr, &sidelist)) {
-		if(!LoadCardList({ file.data(), file.size() }, &mainlist, separated ? &extralist : nullptr, &sidelist))
-			return false;
+        const auto fullname = epro::format(EPRO_TEXT("{}/deck/{}.ydk"), gGameConfig->data_directory, name);
+	if(!LoadCardList(fullname, &mainlist, separated ? &extralist : nullptr, &sidelist)) {
+		return false;
 	}
 	LoadDeck(out, mainlist, sidelist, separated ? &extralist : nullptr);
 	return true;
@@ -415,7 +418,7 @@ bool DeckManager::LoadSide(Deck& deck, uint32_t* dbuf, uint32_t mainc, uint32_t
 	return true;
 }
 bool DeckManager::SaveDeck(epro::path_stringview name, const Deck& deck) {
-	const auto fullname = epro::format(EPRO_TEXT("./deck/{}.ydk"), name);
+	const auto fullname = epro::format(EPRO_TEXT("{}/deck/{}.ydk"), gGameConfig->data_directory, name);
 	FileStream deckfile{ fullname, FileStream::out };
 	if(deckfile.fail())
 		return false;
@@ -431,7 +434,7 @@ bool DeckManager::SaveDeck(epro::path_stringview name, const Deck& deck) {
 	return true;
 }
 bool DeckManager::SaveDeck(epro::path_stringview name, const cardlist_type& mainlist, const cardlist_type& extralist, const cardlist_type& sidelist) {
-	const auto fullname = epro::format(EPRO_TEXT("./deck/{}.ydk"), name);
+	const auto fullname = epro::format(EPRO_TEXT("{}/deck/{}.ydk"), gGameConfig->data_directory, name);
 	FileStream deckfile{ fullname, FileStream::out };
 	if(deckfile.fail())
 		return false;
@@ -574,9 +577,10 @@ bool DeckManager::ImportDeckBase64Omega(Deck& deck, epro::wstringview buffer) {
 	return true;
 }
 bool DeckManager::DeleteDeck(Deck& deck, epro::path_stringview name) {
-	return Utils::FileDelete(epro::format(EPRO_TEXT("./deck/{}.ydk"), name));
+	return Utils::FileDelete(epro::format(EPRO_TEXT("{}/deck/{}.ydk"), gGameConfig->data_directory, name));
 }
 bool DeckManager::RenameDeck(epro::path_stringview oldname, epro::path_stringview newname) {
-	return Utils::FileMove(epro::format(EPRO_TEXT("./deck/{}.ydk"), oldname), epro::format(EPRO_TEXT("./deck/{}.ydk"), newname));
+	epro::path_string deck = gGameConfig->data_directory / EPRO_TEXT("deck");
+	return Utils::FileMove(deck / oldname + EPRO_TEXT(".ydk"), deck / newname + EPRO_TEXT(".ydk"));
 }
 }
diff --git a/gframe/deck_manager.h b/gframe/deck_manager.h
index 9eb56282..ebd9793a 100644
--- a/gframe/deck_manager.h
+++ b/gframe/deck_manager.h
@@ -8,6 +8,7 @@
 #include "text_types.h"
 #include "data_manager.h"
 #include "deck.h"
+#include "game_config.h"
 
 namespace ygo {
 
diff --git a/gframe/game.cpp b/gframe/game.cpp
index 2490d0e8..29b1e437 100644
--- a/gframe/game.cpp
+++ b/gframe/game.cpp
@@ -147,7 +147,7 @@ void Game::Initialize() {
 	if(!(ocgcore = LoadOCGcore(Utils::GetWorkingDirectory())) && !(ocgcore = LoadOCGcore(epro::format(EPRO_TEXT("{}/expansions/"), Utils::GetWorkingDirectory()))))
 		coreloaded = false;
 #endif
-	skinSystem = new CGUISkinSystem(epro::format(EPRO_TEXT("{}/skin"), Utils::GetWorkingDirectory()).data(), device);
+	skinSystem = new CGUISkinSystem(epro::format(EPRO_TEXT("{}/skin"), gGameConfig->data_directory).data(), device);
 	if(!skinSystem)
 		throw std::runtime_error("Couldn't create skin system");
 	linePatternGL = 0x0f0f;
@@ -749,7 +749,7 @@ void Game::Initialize() {
 	wReplay->getCloseButton()->setVisible(false);
 	wReplay->setVisible(false);
 	lstReplayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wReplay, LISTBOX_REPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
-	lstReplayList->setWorkingPath(L"./replay", true);
+	lstReplayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("replay")), true);
 	lstReplayList->addFilteredExtensions({L"yrp", L"yrpx"});
 	lstReplayList->setItemHeight(Scale(18));
 	btnLoadReplay = env->addButton(Scale(470, 355, 570, 380), wReplay, BUTTON_LOAD_REPLAY, gDataManager->GetSysString(1348).data());
@@ -789,7 +789,7 @@ void Game::Initialize() {
 	wSinglePlay->setVisible(false);
 	lstSinglePlayList = irr::gui::CGUIFileSelectListBox::addFileSelectListBox(env, wSinglePlay, LISTBOX_SINGLEPLAY_LIST, Scale(10, 30, 350, 400), filesystem, true, true, false);
 	lstSinglePlayList->setItemHeight(Scale(18));
-	lstSinglePlayList->setWorkingPath(L"./puzzles", true);
+	lstSinglePlayList->setWorkingPath(Utils::ToUnicodeIfNeeded(gGameConfig->data_directory / EPRO_TEXT("puzzles")), true);
 	lstSinglePlayList->addFilteredExtensions({L"lua"});
 	btnLoadSinglePlay = env->addButton(Scale(470, 355, 570, 380), wSinglePlay, BUTTON_LOAD_SINGLEPLAY, gDataManager->GetSysString(1357).data());
 	defaultStrings.emplace_back(btnLoadSinglePlay, 1357);
@@ -2328,7 +2328,7 @@ bool Game::ApplySkin(const epro::path_string& skinname, bool reload, bool firstr
 #include "custom_skin_enum.inl"
 #undef DECLR
 #undef CLR
-			imageManager.ChangeTextures(epro::format(EPRO_TEXT("./skin/{}/textures/"), prev_skin));
+			imageManager.ChangeTextures(epro::format(EPRO_TEXT("{}/skin/{}/textures/"), gGameConfig->data_directory, prev_skin));
 		} else {
 			if(firstrun)
 				return false;
@@ -2383,7 +2383,7 @@ bool Game::ApplySkin(const epro::path_string& skinname, bool reload, bool firstr
 }
 void Game::RefreshDeck(irr::gui::IGUIComboBox* cbDeck) {
 	cbDeck->clear();
-	for(auto& file : Utils::FindFiles(EPRO_TEXT("./deck/"), { EPRO_TEXT("ydk") })) {
+	for(auto& file : Utils::FindFiles(gGameConfig->data_directory / EPRO_TEXT("deck/"), { EPRO_TEXT("ydk") })) {
 		file.erase(file.size() - 4);
 		cbDeck->addItem(Utils::ToUnicodeIfNeeded(file).data());
 	}
@@ -2531,7 +2531,7 @@ void Game::SaveConfig() {
 	gGameConfig->useIntegratedGpu = gSettings.chkIntegratedGPU->isChecked();
 #endif
 	gGameConfig->driver_type = static_cast<irr::video::E_DRIVER_TYPE>(gSettings.cbVideoDriver->getItemData(gSettings.cbVideoDriver->getSelected()));
-	gGameConfig->Save(EPRO_TEXT("./config/system.conf"));
+	gGameConfig->Save(gGameConfig->config_directory / EPRO_TEXT("system.conf"));
 }
 void Game::LoadServers() {
 	for(auto& _config : { &gGameConfig->user_configs, &gGameConfig->configs }) {
@@ -3586,6 +3586,8 @@ void Game::ValidateName(irr::gui::IGUIElement* obj) {
 		obj->setText(text.data());
 }
 epro::path_string Game::FindScript(epro::path_stringview name, irr::io::IReadFile** retarchive) {
+ 	if (!Utils::PathIsRelative(name))
+		return epro::path_string(name);
 	for(auto& path : script_dirs) {
 		if(path == EPRO_TEXT("archives")) {
 			if(auto tmp = Utils::FindFileInArchives(EPRO_TEXT("script/"), name)) {
@@ -3712,32 +3714,32 @@ void Game::PopulateResourcesDirectories() {
 				cover_dirs.push_back(image_dir / EPRO_TEXT("cover/"));
 				field_dirs.push_back(image_dir / EPRO_TEXT("field/"));
 			});
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
 #else
-	script_dirs.push_back(EPRO_TEXT("./expansions/script/"));
-	auto expansions_subdirs = Utils::FindSubfolders(EPRO_TEXT("./expansions/script/"));
-	script_dirs.insert(script_dirs.end(), std::make_move_iterator(expansions_subdirs.begin()), std::make_move_iterator(expansions_subdirs.end()));
-	script_dirs.push_back(EPRO_TEXT("archives"));
-	script_dirs.push_back(EPRO_TEXT("./script/"));
-	auto script_subdirs = Utils::FindSubfolders(EPRO_TEXT("./script/"));
-	script_dirs.insert(script_dirs.end(), std::make_move_iterator(script_subdirs.begin()), std::make_move_iterator(script_subdirs.end()));
-	pic_dirs.push_back(EPRO_TEXT("./expansions/pics/"));
-	pic_dirs.push_back(EPRO_TEXT("archives"));
-	pic_dirs.push_back(EPRO_TEXT("./pics/"));
-	cover_dirs.push_back(EPRO_TEXT("./expansions/pics/cover/"));
-	cover_dirs.push_back(EPRO_TEXT("archives"));
-	cover_dirs.push_back(EPRO_TEXT("./pics/cover/"));
-	field_dirs.push_back(EPRO_TEXT("./expansions/pics/field/"));
-	field_dirs.push_back(EPRO_TEXT("archives"));
-	field_dirs.push_back(EPRO_TEXT("./pics/field/"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	auto expansions_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./expansions/script/"));
+	script_dirs.insert(script_dirs.end(), expansions_subdirs.begin(), expansions_subdirs.end());
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	script_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	auto script_subdirs = Utils::FindSubfolders(gGameConfig->data_directory / EPRO_TEXT("./script/"));
+	script_dirs.insert(script_dirs.end(), script_subdirs.begin(), script_subdirs.end());
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/"));
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/cover/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./expansions/pics/field/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("archives"));
 #endif
+	pic_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->data_directory / EPRO_TEXT("./pics/field/"));
+	pic_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/"));
+	cover_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/cover/"));
+	field_dirs.push_back(gGameConfig->cache_directory / EPRO_TEXT("./pics/field/"));
 }
 
 void Game::PopulateLocales() {
 	locales.clear();
-	for(auto& locale : Utils::FindSubfolders(EPRO_TEXT("./config/languages/"), 1, false)) {
+	for(auto& locale : Utils::FindSubfolders(gGameConfig->config_directory / EPRO_TEXT("languages/"), 1, false)) {
 		locales.emplace_back(locale, std::vector<epro::path_string>());
 	}
 }
@@ -3754,7 +3756,7 @@ void Game::ApplyLocale(size_t index, bool forced) {
 	if(index > 0) {
 		try {
 			gGameConfig->locale = locales[index - 1].first;
-			auto locale = epro::format(EPRO_TEXT("./config/languages/{}"), gGameConfig->locale);
+			auto locale = epro::format(EPRO_TEXT("{}/config/languages/{}"), gGameConfig->config_directory, gGameConfig->locale);
 			for(auto& file : Utils::FindFiles(locale, { EPRO_TEXT("cdb") })) {
 				gDataManager->LoadLocaleDB(epro::format(EPRO_TEXT("{}/{}"), locale, file));
 			}
diff --git a/gframe/game_config.cpp b/gframe/game_config.cpp
index cbc38269..adf3912a 100644
--- a/gframe/game_config.cpp
+++ b/gframe/game_config.cpp
@@ -7,14 +7,93 @@
 #include "config.h"
 #include "logging.h"
 #include "file_stream.h"
+#if defined(__MINGW32__) && defined(UNICODE)
+#include <fcntl.h>
+#include <ext/stdio_filebuf.h>
+#endif
+#if XDG_ENVIRONMENT && _WIN32
+#include <Shlobj.h>
+#include <Shlobj_core.h>
+
+namespace
+{
+	epro::path_string
+	GetSpecialFolder (int csidl)
+	{
+		std::vector<wchar_t> path;
+		HRESULT hr;
+		LPITEMIDLIST pidl = NULL;
+		BOOL b;
+		epro::path_string result;
+		path.reserve(MAX_PATH+1);
+
+		hr = SHGetFolderPathA (NULL, csidl, NULL, 0, path.data());
+		if (hr == S_OK)
+			return Utils::ToPathString(path.data());
+		else
+			return EPRO_TEXT("."); // default to working directory
+	}
+}
+#endif
 
 namespace ygo {
 
 GameConfig::GameConfig() {
-	Load(EPRO_TEXT("./config/system.conf"));
+#if XDG_ENVIRONMENT
+	{
+#ifndef _WIN32
+		const char* home_env = getenv("HOME");
+		epro::path_string home = Utils::ToPathString(home_env);
+#endif
+
+		const char* data_home = getenv("XDG_DATA_HOME");
+		const char* cache_home = getenv("XDG_CACHE_HOME");
+		const char* config_home = getenv("XDG_CONFIG_HOME");
+
+		if (cache_home)
+			cache_directory = Utils::ToPathString(cache_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			cache_directory = GetSpecialFolder(CSIDL_INTERNET_CACHE) / EPRO_TEXT("ygopro");
+#else
+			cache_directory = home / EPRO_TEXT(".cache/ygopro");
+#endif
+		}
+		if (data_home)
+			data_directory = Utils::ToPathString(data_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			data_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			data_directory = home / EPRO_TEXT(".local/share/ygopro");
+#endif
+		}
+
+		if (config_home)
+			config_directory = Utils::ToPathString(config_home) / EPRO_TEXT("ygopro");
+		else {
+#ifdef _WIN32
+			config_directory = GetSpecialFolder(CSIDL_LOCAL_APPDATA) / EPRO_TEXT("ygopro");
+#else
+			config_directory = home / EPRO_TEXT(".config/ygopro");
+#endif
+		}
+
+#ifdef _WIN32
+		sysconfig_directory = EPRO_TEXT("C:/ProjectIgnis");
+		sysdata_directory = EPRO_TEXT("C:/ProjectIgnis");
+#else
+		sysconfig_directory = EPRO_TEXT("/etc/ygopro");
+		sysdata_directory = EPRO_TEXT("/usr/share/ygopro");
+#endif
+	}
+#endif
+	if(!Load(config_directory / EPRO_TEXT("system.conf")))
+		Load(sysconfig_directory / EPRO_TEXT("system.conf"));
+
 	if(configs.empty()) {
 		{
-			FileStream conf_file{ EPRO_TEXT("./config/configs.json"), FileStream::in };
+			FileStream conf_file{ config_directory / EPRO_TEXT("configs.json"), FileStream::in };
 			if(!conf_file.fail()) {
 				try {
 					conf_file >> configs;
@@ -26,7 +105,7 @@ GameConfig::GameConfig() {
 			}
 		}
 		{
-			FileStream user_conf_file{ EPRO_TEXT("./config/user_configs.json"), FileStream::in };
+			FileStream user_conf_file{ config_directory / EPRO_TEXT("user_configs.json"), FileStream::in };
 			if(!user_conf_file.fail()) {
 				try {
 					user_conf_file >> user_configs;
diff --git a/gframe/game_config.h b/gframe/game_config.h
index a441b6bf..10009a77 100644
--- a/gframe/game_config.h
+++ b/gframe/game_config.h
@@ -37,6 +37,13 @@ struct GameConfig
 	std::wstring roompass; // NOT SERIALIZED
 	std::string ssl_certificate_path;
 
+	epro::path_string cache_directory = EPRO_TEXT("./");
+	epro::path_string config_directory = EPRO_TEXT("./config");
+	epro::path_string data_directory = EPRO_TEXT("./");
+
+	epro::path_string sysconfig_directory = EPRO_TEXT("./config");
+	epro::path_string sysdata_directory = EPRO_TEXT("./");
+
 	nlohmann::json configs;
 	nlohmann::json user_configs;
 };
diff --git a/gframe/image_downloader.cpp b/gframe/image_downloader.cpp
index 87178721..58614728 100644
--- a/gframe/image_downloader.cpp
+++ b/gframe/image_downloader.cpp
@@ -121,28 +121,24 @@ void ImageDownloader::DownloadPic() {
 		auto& map_elem = downloading_images[type][code];
 		map_elem.status = downloadStatus::DOWNLOADING;
 		lck.unlock();
-		auto name = epro::format(EPRO_TEXT("./pics/temp/{}"), code);
+		auto name = epro::format(EPRO_TEXT("{}/pics/temp/{}"), gGameConfig->cache_directory, code);
 		if(type == imgType::THUMB)
 			type = imgType::ART;
-		epro::path_stringview dest;
-		switch(type) {
-			case imgType::ART:
-			case imgType::THUMB: {
-				dest = EPRO_TEXT("./pics/{}"_sv);
-				break;
-			}
-			case imgType::FIELD: {
-				dest = EPRO_TEXT("./pics/field/{}"_sv);
-				name.append(EPRO_TEXT("_f"));
-				break;
+		auto dest_folder = [type, &name, code]()->epro::path_string {
+			const epro::path_string code_s = fmt::format(EPRO_TEXT("{}"), code);
+			switch(type) {
+				default:
+				case imgType::ART:
+				case imgType::THUMB:
+					return gGameConfig->cache_directory / EPRO_TEXT("pics") / code_s;
+				case imgType::FIELD:
+					name.append(EPRO_TEXT("_f"));
+					return gGameConfig->cache_directory / EPRO_TEXT("pics/field") / code_s;
+				case imgType::COVER:
+					name.append(EPRO_TEXT("_c"));
+					return gGameConfig->cache_directory / EPRO_TEXT("pics/cover") / code_s;
 			}
-			case imgType::COVER: {
-				dest = EPRO_TEXT("./pics/cover/{}"_sv);
-				name.append(EPRO_TEXT("_c"));
-				break;
-			}
-		}
-		auto dest_folder = epro::format(dest, code);
+		}();
 		CURLcode res{ static_cast<CURLcode>(1) };
 		for(auto& src : pic_urls) {
 			if(src.type != type)
diff --git a/gframe/image_manager.cpp b/gframe/image_manager.cpp
index 2305348f..dba774f3 100644
--- a/gframe/image_manager.cpp
+++ b/gframe/image_manager.cpp
@@ -11,7 +11,7 @@
 #include "image_downloader.h"
 #include "game.h"
 
-#define BASE_PATH EPRO_TEXT("./textures/")
+#define BASE_PATH EPRO_TEXT("textures/")
 
 namespace ygo {
 
@@ -48,20 +48,24 @@ ImageManager::~ImageManager() {
 irr::video::ITexture* ImageManager::loadTextureFixedSize(epro::path_stringview texture_name, int width, int height) {
 	width = mainGame->Scale(width);
 	height = mainGame->Scale(height);
-	irr::video::ITexture* ret = GetTextureFromFile(epro::format(EPRO_TEXT("{}{}.png"), textures_path, texture_name).data(), width, height);
-	if(ret == nullptr)
-		ret = GetTextureFromFile(epro::format(EPRO_TEXT("{}{}.jpg"), textures_path, texture_name).data(), width, height);
+	irr::video::ITexture* ret;
+        ret = GetTextureFromFile(epro::format(EPRO_TEXT("{}/{}.png"), textures_path, texture_name).data(), width, height);
+	if(ret == nullptr) ret = GetTextureFromFile(epro::format(EPRO_TEXT("{}/{}.jpg"), textures_path, texture_name).data(), width, height);
+	if(ret == nullptr) ret = GetTextureFromFile(epro::format(EPRO_TEXT("{}/{}.png"), textures_path2, texture_name).data(), width, height);
+	if(ret == nullptr) ret = GetTextureFromFile(epro::format(EPRO_TEXT("{}/{}.jpg"), textures_path2, texture_name).data(), width, height);
 	return ret;
 }
 irr::video::ITexture* ImageManager::loadTextureAnySize(epro::path_stringview texture_name) {
-	irr::video::ITexture* ret = driver->getTexture(epro::format(EPRO_TEXT("{}{}.png"), textures_path, texture_name).data());
-	if(ret == nullptr)
-		ret = driver->getTexture(epro::format(EPRO_TEXT("{}{}.jpg"), textures_path, texture_name).data());
+	irr::video::ITexture* ret = driver->getTexture(epro::format(EPRO_TEXT("{}/{}.png"), textures_path, texture_name).data());
+	if(ret == nullptr) ret = driver->getTexture(epro::format(EPRO_TEXT("{}/{}.jpg"), textures_path, texture_name).data());
+	if(ret == nullptr) ret = driver->getTexture(epro::format(EPRO_TEXT("{}/{}.png"), textures_path2, texture_name).data());
+	if(ret == nullptr) ret = driver->getTexture(epro::format(EPRO_TEXT("{}/{}.jpg"), textures_path2, texture_name).data());
 	return ret;
 }
 bool ImageManager::Initial() {
 	timestamp_id = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
-	textures_path = BASE_PATH;
+	textures_path = gGameConfig->data_directory / BASE_PATH;
+	textures_path2 = gGameConfig->sysdata_directory / BASE_PATH;
 
 	tCover[0] = loadTextureFixedSize(EPRO_TEXT("cover"_sv), CARD_IMG_WIDTH, CARD_IMG_HEIGHT);
 	ASSERT_TEXTURE_LOADED(tCover[0], "cover");
@@ -316,7 +320,7 @@ void ImageManager::ChangeTextures(epro::path_stringview _path) {
 #undef REPLACE_TEXTURE_ANY_SIZE
 #undef REPLACE_TEXTURE_WITH_FIXED_SIZE
 void ImageManager::ResetTextures() {
-	ChangeTextures(BASE_PATH);
+	ChangeTextures(gGameConfig->data_directory / BASE_PATH);
 }
 void ImageManager::SetDevice(irr::IrrlichtDevice* dev) {
 	device = dev;
@@ -351,6 +355,7 @@ void ImageManager::ClearTexture(bool resize) {
 	}
 	tFields.clear();
 }
+
 void ImageManager::RefreshCachedTextures() {
 	auto LoadTexture = [this](int index, texture_map& dest, auto& size, imgType type) {
 		auto& src = loaded_pics[index];
@@ -412,11 +417,11 @@ void ImageManager::ClearFutureObjects() {
 }
 
 void ImageManager::RefreshCovers() {
-	const auto is_base_path = textures_path == BASE_PATH;
+	const auto is_base_path = textures_path == gGameConfig->data_directory / BASE_PATH;
 	auto reloadTextureWithNewSizes = [this, is_base_path, width = (int)sizes[1].first, height = (int)sizes[1].second](auto*& texture, epro::path_stringview texture_name) {
 		auto new_texture = loadTextureFixedSize(texture_name, width, height);
 		if(!new_texture && !is_base_path) {
-			const auto old_textures_path = std::exchange(textures_path, BASE_PATH);
+			const auto old_textures_path = std::exchange(textures_path, gGameConfig->data_directory / BASE_PATH);
 			new_texture = loadTextureFixedSize(texture_name, width, height);
 			textures_path = old_textures_path;
 		}
diff --git a/gframe/image_manager.h b/gframe/image_manager.h
index 5df10e00..2b64007d 100644
--- a/gframe/image_manager.h
+++ b/gframe/image_manager.h
@@ -148,6 +148,7 @@ private:
 	void replaceTextureLoadingAnySize(irr::video::ITexture*& texture, irr::video::ITexture* fallback, epro::path_stringview texture_name);
 	load_return LoadCardTexture(uint32_t code, imgType type, const std::atomic<irr::s32>& width, const std::atomic<irr::s32>& height, chrono_time timestamp_id, const std::atomic<chrono_time>& source_timestamp_id);
 	epro::path_string textures_path;
+	epro::path_string textures_path2;
 	std::pair<std::atomic<irr::s32>, std::atomic<irr::s32>> sizes[3];
 	std::atomic<chrono_time> timestamp_id;
 	std::map<epro::path_string, irr::video::ITexture*> g_txrCache;
diff --git a/gframe/premake5.lua b/gframe/premake5.lua
index f402ed38..bc38d1ab 100644
--- a/gframe/premake5.lua
+++ b/gframe/premake5.lua
@@ -56,6 +56,9 @@ local ygopro_config=function(static_core)
 	if _OPTIONS["environment-paths"] then
 		defines { "YGOPRO_ENVIRONMENT_PATHS" }
 	end
+	if _OPTIONS["xdg-environment"] then
+		defines { "XDG_ENVIRONMENT" }
+	end
 
 	includedirs "../ocgcore"
 	links { "clzma", "Irrlicht" }
diff --git a/gframe/replay.cpp b/gframe/replay.cpp
index a16333f4..47782921 100644
--- a/gframe/replay.cpp
+++ b/gframe/replay.cpp
@@ -3,6 +3,7 @@
 #include <fmt/format.h>
 #include "lzma/LzmaLib.h"
 #include "common.h"
+#include "game_config.h"
 #include "utils.h"
 #include "file_stream.h"
 
@@ -77,7 +78,7 @@ void Replay::EndRecord(size_t size) {
 	is_recording = false;
 }
 void Replay::SaveReplay(const epro::path_string& name) {
-	auto replay_file = fileopen(epro::format(EPRO_TEXT("./replay/{}.yrpX"), name).data(), "wb");
+	auto replay_file = fileopen(epro::format(EPRO_TEXT("{}/replay/{}.yrpX"), gGameConfig->data_directory, name).data(), "wb");
 	if(replay_file == nullptr)
 		return;
 	auto header_len = (pheader.base.flag & REPLAY_EXTENDED_HEADER) ? sizeof(ExtendedReplayHeader) : sizeof(ReplayHeader);
@@ -133,7 +134,7 @@ bool Replay::OpenReplay(const epro::path_string& name) {
 	std::vector<uint8_t> contents;
 	FileStream replay_file{ name, FileStream::in | FileStream::binary };
 	if(replay_file.fail()) {
-		FileStream replay_file2{ EPRO_TEXT("./replay/") + name, FileStream::in | FileStream::binary };
+		FileStream replay_file2{gGameConfig->data_directory /  EPRO_TEXT("replay/") + name, FileStream::in | FileStream::binary };
 		if(replay_file2.fail()) {
 			replay_name.clear();
 			return false;
diff --git a/gframe/single_mode.cpp b/gframe/single_mode.cpp
index a4945c9f..eb34d3f6 100644
--- a/gframe/single_mode.cpp
+++ b/gframe/single_mode.cpp
@@ -155,7 +155,7 @@ restart:
 		if(open_file) {
 			script_name = Utils::ToUTF8IfNeeded(open_file_name);
 			if(!mainGame->LoadScript(pduel, script_name)) {
-				script_name = epro::format("./puzzles/{}" ,script_name);
+				script_name = epro::format("{}/puzzles/{}", gGameConfig->data_directory, script_name);
 				loaded = mainGame->LoadScript(pduel, script_name);
 			}
 		} else {
diff --git a/gframe/sound_manager.cpp b/gframe/sound_manager.cpp
index 259ff880..43332c9c 100644
--- a/gframe/sound_manager.cpp
+++ b/gframe/sound_manager.cpp
@@ -12,12 +12,13 @@
 #include "sound_sfml.h"
 #define BACKEND SoundSFML
 #endif
+#include "game_config.h"
 
 namespace ygo {
 SoundManager::SoundManager(double sounds_volume, double music_volume, bool sounds_enabled, bool music_enabled) {
 #ifdef BACKEND
 	fmt::print("Using: " STR(BACKEND)" for audio playback.\n");
-	working_dir = Utils::ToUTF8IfNeeded(Utils::GetWorkingDirectory());
+	working_dir = Utils::ToUTF8IfNeeded(gGameConfig->data_directory);
 	soundsEnabled = sounds_enabled;
 	musicEnabled = music_enabled;
 	try {
@@ -53,15 +54,15 @@ bool SoundManager::IsUsable() {
 }
 void SoundManager::RefreshBGMList() {
 #ifdef BACKEND
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/duel"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/menu"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/deck"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/advantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/disadvantage"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/win"));
-	Utils::MakeDirectory(EPRO_TEXT("./sound/BGM/lose"));
-	for (auto& list : BGMList)
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/duel"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/menu"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/deck"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/advantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/disadvantage"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/win"));
+	Utils::MakeDirectory(Utils::ToPathString(working_dir) / EPRO_TEXT("sound/BGM/lose"));
+	for (auto list : BGMList)
 		list.clear();
 	RefreshBGMDir(EPRO_TEXT(""), BGM::DUEL);
 	RefreshBGMDir(EPRO_TEXT("duel"), BGM::DUEL);
@@ -76,35 +77,35 @@ void SoundManager::RefreshBGMList() {
 void SoundManager::RefreshSoundsList() {
 #ifdef BACKEND
 	static constexpr std::pair<SFX, epro::path_stringview> fx[]{
-		{SUMMON, EPRO_TEXT("./sound/summon.{}"_sv)},
-		{SPECIAL_SUMMON, EPRO_TEXT("./sound/specialsummon.{}"_sv)},
-		{ACTIVATE, EPRO_TEXT("./sound/activate.{}"_sv)},
-		{SET, EPRO_TEXT("./sound/set.{}"_sv)},
-		{FLIP, EPRO_TEXT("./sound/flip.{}"_sv)},
-		{REVEAL, EPRO_TEXT("./sound/reveal.{}"_sv)},
-		{EQUIP, EPRO_TEXT("./sound/equip.{}"_sv)},
-		{DESTROYED, EPRO_TEXT("./sound/destroyed.{}"_sv)},
-		{BANISHED, EPRO_TEXT("./sound/banished.{}"_sv)},
-		{TOKEN, EPRO_TEXT("./sound/token.{}"_sv)},
-		{ATTACK, EPRO_TEXT("./sound/attack.{}"_sv)},
-		{DIRECT_ATTACK, EPRO_TEXT("./sound/directattack.{}"_sv)},
-		{DRAW, EPRO_TEXT("./sound/draw.{}"_sv)},
-		{SHUFFLE, EPRO_TEXT("./sound/shuffle.{}"_sv)},
-		{DAMAGE, EPRO_TEXT("./sound/damage.{}"_sv)},
-		{RECOVER, EPRO_TEXT("./sound/gainlp.{}"_sv)},
-		{COUNTER_ADD, EPRO_TEXT("./sound/addcounter.{}"_sv)},
-		{COUNTER_REMOVE, EPRO_TEXT("./sound/removecounter.{}"_sv)},
-		{COIN, EPRO_TEXT("./sound/coinflip.{}"_sv)},
-		{DICE, EPRO_TEXT("./sound/diceroll.{}"_sv)},
-		{NEXT_TURN, EPRO_TEXT("./sound/nextturn.{}"_sv)},
-		{PHASE, EPRO_TEXT("./sound/phase.{}"_sv)},
-		{PLAYER_ENTER, EPRO_TEXT("./sound/playerenter.{}"_sv)},
-		{CHAT, EPRO_TEXT("./sound/chatmessage.{}"_sv)}
+		{SUMMON, EPRO_TEXT("sound/summon.{}"_sv)},
+		{SPECIAL_SUMMON, EPRO_TEXT("sound/specialsummon.{}"_sv)},
+		{ACTIVATE, EPRO_TEXT("sound/activate.{}"_sv)},
+		{SET, EPRO_TEXT("sound/set.{}"_sv)},
+		{FLIP, EPRO_TEXT("sound/flip.{}"_sv)},
+		{REVEAL, EPRO_TEXT("sound/reveal.{}"_sv)},
+		{EQUIP, EPRO_TEXT("sound/equip.{}"_sv)},
+		{DESTROYED, EPRO_TEXT("sound/destroyed.{}"_sv)},
+		{BANISHED, EPRO_TEXT("sound/banished.{}"_sv)},
+		{TOKEN, EPRO_TEXT("sound/token.{}"_sv)},
+		{ATTACK, EPRO_TEXT("sound/attack.{}"_sv)},
+		{DIRECT_ATTACK, EPRO_TEXT("sound/directattack.{}"_sv)},
+		{DRAW, EPRO_TEXT("sound/draw.{}"_sv)},
+		{SHUFFLE, EPRO_TEXT("sound/shuffle.{}"_sv)},
+		{DAMAGE, EPRO_TEXT("sound/damage.{}"_sv)},
+		{RECOVER, EPRO_TEXT("sound/gainlp.{}"_sv)},
+		{COUNTER_ADD, EPRO_TEXT("sound/addcounter.{}"_sv)},
+		{COUNTER_REMOVE, EPRO_TEXT("sound/removecounter.{}"_sv)},
+		{COIN, EPRO_TEXT("sound/coinflip.{}"_sv)},
+		{DICE, EPRO_TEXT("sound/diceroll.{}"_sv)},
+		{NEXT_TURN, EPRO_TEXT("sound/nextturn.{}"_sv)},
+		{PHASE, EPRO_TEXT("sound/phase.{}"_sv)},
+		{PLAYER_ENTER, EPRO_TEXT("sound/playerenter.{}"_sv)},
+		{CHAT, EPRO_TEXT("sound/chatmessage.{}"_sv)}
 	};
 	const auto extensions = mixer->GetSupportedSoundExtensions();
 	for(const auto& sound : fx) {
 		for(const auto& ext : extensions) {
-			const auto filename = epro::format(sound.second, ext);
+			const auto filename = Utils::ToPathString(working_dir) /epro::format(sound.second, ext);
 			if(Utils::FileExists(filename)) {
 				SFXList[sound.first] = Utils::ToUTF8IfNeeded(filename);
 				break;
@@ -115,7 +116,7 @@ void SoundManager::RefreshSoundsList() {
 }
 void SoundManager::RefreshBGMDir(epro::path_stringview path, BGM scene) {
 #ifdef BACKEND
-	for(auto& file : Utils::FindFiles(epro::format(EPRO_TEXT("./sound/BGM/{}"), path), mixer->GetSupportedMusicExtensions())) {
+	for(auto& file : Utils::FindFiles(epro::format(EPRO_TEXT("{}/sound/BGM/{}"), Utils::ToPathString(working_dir), path), mixer->GetSupportedMusicExtensions())) {
 		auto conv = Utils::ToUTF8IfNeeded(epro::format(EPRO_TEXT("{}/{}"), path, file));
 		BGMList[BGM::ALL].push_back(conv);
 		BGMList[scene].push_back(std::move(conv));
diff --git a/gframe/utils.cpp b/gframe/utils.cpp
index 16f09118..326a181a 100644
--- a/gframe/utils.cpp
+++ b/gframe/utils.cpp
@@ -1,4 +1,5 @@
 #include "utils.h"
+#include "game_config.h"
 #include <cmath> // std::round
 #include "config.h"
 #ifdef _WIN32
@@ -14,6 +15,8 @@
 #endif
 #include <shellapi.h> // ShellExecute
 #include "utils_gui.h"
+#include <shlwapi.h> // PathIsRelative{,A,W}
+#undef PathIsRelative
 #else
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
@@ -41,6 +44,8 @@ using Stat = struct stat;
 #endif //_WIN32
 #include <IFileArchive.h>
 #include <IFileSystem.h>
+#include <iostream>
+#include <sstream>
 #include <fmt/format.h>
 #include <IOSOperator.h>
 #include "bufferio.h"
@@ -75,6 +80,16 @@ inline void NameThreadMsvc(const char* threadName) {
 	__try {	RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info); }
 	__except(EXCEPTION_EXECUTE_HANDLER) {}
 }
+
+bool PathIsRelative(const epro::path_char* path)
+{
+#ifdef UNICODE
+	return PathIsRelativeW(path);
+#else
+	return PathIsRelativeA(path);
+#endif
+}
+}
 #pragma warning(pop)
 #endif
 const auto PSetThreadDescription = [] {
@@ -224,6 +239,14 @@ namespace ygo {
 		return false;
 	}
 
+	bool Utils::PathIsRelative(epro::path_stringview path) {
+#ifdef _WIN32
+		return PathIsRelativeW(ToUnicodeIfNeeded(path).data());
+#else
+		return path[0] != EPRO_TEXT('/');
+#endif
+	}
+
 	bool Utils::MakeDirectory(epro::path_stringview path) {
 #ifdef _WIN32
 		return SetLastErrorStringIfFailed(CreateDirectory(path.data(), nullptr) || ERROR_ALREADY_EXISTS == GetLastError());
@@ -400,15 +423,19 @@ namespace ygo {
 
 	void Utils::CreateResourceFolders() {
 		//create directories if missing
-		MakeDirectory(EPRO_TEXT("deck"));
-		MakeDirectory(EPRO_TEXT("puzzles"));
-		MakeDirectory(EPRO_TEXT("pics"));
-		MakeDirectory(EPRO_TEXT("pics/field"));
-		MakeDirectory(EPRO_TEXT("pics/cover"));
-		MakeDirectory(EPRO_TEXT("pics/temp/"));
-		ClearDirectory(EPRO_TEXT("pics/temp/"));
-		MakeDirectory(EPRO_TEXT("replay"));
-		MakeDirectory(EPRO_TEXT("screenshots"));
+		MakeDirectory(gGameConfig->config_directory);
+		MakeDirectory(gGameConfig->data_directory);
+		MakeDirectory(gGameConfig->cache_directory);
+
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("deck"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("puzzles"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/field"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/cover"));
+		MakeDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		ClearDirectory(gGameConfig->cache_directory / EPRO_TEXT("pics/temp/"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("replay"));
+		MakeDirectory(gGameConfig->data_directory / EPRO_TEXT("screenshots"));
 	}
 
 	std::vector<epro::path_string> Utils::FindFiles(epro::path_stringview path, const std::vector<epro::path_stringview>& extensions, int subdirectorylayers) {
diff --git a/gframe/utils.h b/gframe/utils.h
index ff00c9f5..07c74925 100644
--- a/gframe/utils.h
+++ b/gframe/utils.h
@@ -57,6 +57,7 @@ namespace ygo {
 		static irr::IOSOperator* OSOperator;
 		static void SetupCrashDumpLogging();
 		static epro::stringview GetLastErrorString();
+		static bool PathIsRelative(epro::path_stringview path);
 		static bool MakeDirectory(epro::path_stringview path);
 		static bool FileCopyFD(int source, int destination);
 		static bool FileCopy(epro::path_stringview source, epro::path_stringview destination);
diff --git a/gframe/utils_gui.cpp b/gframe/utils_gui.cpp
index 3db81e9d..f0493043 100644
--- a/gframe/utils_gui.cpp
+++ b/gframe/utils_gui.cpp
@@ -188,7 +188,7 @@ bool GUIUtils::TakeScreenshot(irr::IrrlichtDevice* device) {
 	if(!image)
 		return false;
 	const auto now = std::time(nullptr);
-	const auto filename = epro::format(EPRO_TEXT("screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), *std::localtime(&now));
+	const auto filename = epro::format(EPRO_TEXT("{}/screenshots/EDOPro {:%Y-%m-%d %H-%M-%S}.png"), gGameConfig->data_directory, *std::localtime(&now));
 	auto written = driver->writeImageToFile(image, { filename.data(), static_cast<irr::u32>(filename.size()) });
 	if(!written)
 		device->getLogger()->log(L"Failed to take screenshot.", irr::ELL_WARNING);
@@ -345,7 +345,7 @@ void GUIUtils::ShowErrorWindow(epro::stringview context, epro::stringview messag
 		nullptr, //icon url, use default, you can change it depending message_type flags
 		nullptr, //not used
 		nullptr, //localization of strings
-		header_ref, //header text 
+		header_ref, //header text
 		message_ref, //message text
 		nullptr, //default "ok" text in button
 		nullptr, //alternate button title
diff --git a/premake5.lua b/premake5.lua
index c2fbb210..2a637f2e 100644
--- a/premake5.lua
+++ b/premake5.lua
@@ -64,6 +64,11 @@ newoption {
 	trigger = "environment-paths",
 	description = "Read databases, scripts and images from YGOPRO_*_PATH"
 }
+newoption
+{
+	trigger = "xdg-environment",
+	description = "Use XDG config, data and cache directories."
+}
 newoption {
 	trigger = "no-core",
 	description = "Ignore the ocgcore subproject and only generate the solution for yroprodll"
-- 
2.39.1

